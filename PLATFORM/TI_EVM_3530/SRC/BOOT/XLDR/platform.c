// Copyright (c) 2013 Micronet Ltd. All rights reserved.
// by Vladimir Zatulovsky
/*
================================================================================
*             Texas Instruments OMAP(TM) Platform Software
* (c) Copyright Texas Instruments, Incorporated. All Rights Reserved.
*
* Use of this software is controlled by the terms and conditions found
* in the license agreement under which this software has been supplied.
*
================================================================================
*/
//
//  File:  platform.c
//
//  This file contains X-Loader startup code for CE317 boards based on OMAP37XX processors
//
#include <bsp.h>
#include <blcommon.h>
#include <fmd.h>
#include <oal.h>
#include <oalex.h>
#include <oal_i2c.h>
#include <constants.h>

//------------------------------------------------------------------------------
//  Defines

// Useful macros for debugging XLDR problems
#ifdef SHIP_BUILD
#define XLDRMSGINIT
#define XLDRMSGDEINIT
#define XLDRMSG(msg)        
#define XLDRHEX(val, len)
#else
#define XLDRMSGINIT         OEMDebugInit()
#define XLDRMSGDEINIT       OEMDebugDeinit()
#define XLDRMSG(msg)        OEMWriteDebugString(msg)
#define XLDRHEX(val, len)   OEMWriteDebugHex(val, len)
#endif

//------------------------------------------------------------------------------
//
//  Function:  disable_watchdog
//
//  Initializes watchdog timer settings
//
static VOID disable_watchdog()
{
    OMAP_WDOG_REGS  *pWdogTimer;
    
    //  Disable the OMAP watchdog timer
    pWdogTimer = OALPAtoUA(OMAP_WDOG2_REGS_PA);

    //  Write out disable seq 1
    OUTREG32(&pWdogTimer->WSPR, WDOG_DISABLE_SEQ1);

    //  Wait for write to complete
    while(INREG32(&pWdogTimer->WWPS));

    //  Write out disable seq 2
    OUTREG32(&pWdogTimer->WSPR, WDOG_DISABLE_SEQ2);

    //  Wait for write to complete
    while(INREG32(&pWdogTimer->WWPS));
}

//------------------------------------------------------------------------------
//
//  Function:  sdrc_pads_setup
//
//  Initializes pin/pad mux settings
//
static void sdrc_pads_setup(void)
{
    OMAP_SYSC_PADCONFS_REGS *pConfig = OALPAtoUA(OMAP_SYSC_PADCONFS_REGS_PA);

    /*SDRC*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D0,   (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D0*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D1,   (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D1*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D2,   (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D2*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D3,   (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D3*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D4,   (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D4*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D5,   (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D5*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D6,   (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D6*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D7,   (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D7*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D8,   (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D8*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D9,   (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D9*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D10,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D10*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D11,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D11*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D12,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D12*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D13,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D13*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D14,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D14*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D15,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D15*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D16,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D16*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D17,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D17*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D18,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D18*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D19,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D19*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D20,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D20*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D21,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D21*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D22,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D22*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D23,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D23*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D24,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D24*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D25,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D25*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D26,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D26*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D27,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D27*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D28,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D28*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D29,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D29*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D30,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D30*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_D31,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_D31*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_CLK,  (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_CLK*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_DQS0, (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_DQS0*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_DQS1, (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_DQS1*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_DQS2, (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_DQS2*/
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_DQS3, (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_DQS3*/ 
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_CKE0, (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); /*SDRC_CKE0*/ 
}

//------------------------------------------------------------------------------
//
//  Function:  gpmc_pads_setup
//
//  Initializes pin/pad mux settings
//
static void gpmc_pads_setup(void)
{
    OMAP_SYSC_PADCONFS_REGS *pConfig = OALPAtoUA(OMAP_SYSC_PADCONFS_REGS_PA);

	/*GPMC*/
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_A1,  	  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_34 USB hub reset
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_A2,  	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_7)); // GPIO_35/TP pad released
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_A3,  	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_36 MCU interrupt
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_A4,  	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_37 MCU temperature IRQ
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_A5,  	  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_38 CAN en
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_A6,  	  (INPUT_ENABLE  | PULL_UP		 | MUX_MODE_4)); // GPIO_39 CAN irq
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_A7,  	  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_40 modem reset
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_A8,  	  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_41 modem en
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_A9,  	  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_42 capacitive touch reset
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_A10, 	  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_43 CAN power en
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_D0,  	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*GPMC_D0*/
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_D1,  	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*GPMC_D1*/
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_D2,  	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*GPMC_D2*/
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_D3,  	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*GPMC_D3*/
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_D4,  	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*GPMC_D4*/
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_D5,  	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*GPMC_D5*/
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_D6,  	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*GPMC_D6*/
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_D7,  	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*GPMC_D7*/
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_D8,  	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*GPMC_D8*/
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_D9,  	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*GPMC_D9*/
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_D10, 	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*GPMC_D10*/
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_D11, 	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*GPMC_D11*/
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_D12, 	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*GPMC_D12*/
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_D13, 	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*GPMC_D13*/
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_D14, 	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*GPMC_D14*/
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_D15, 	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*GPMC_D15*/
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_nCS0,	  (INPUT_DISABLE | PULL_UP		 | MUX_MODE_0)); /*GPMC_nCS0*/
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_nCS1,	  (INPUT_DISABLE | PULL_UP		 | MUX_MODE_0)); /*GPMC_nCS1*/
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_nCS2,	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_7)); // released
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_nCS3,	  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // released
	OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_nCS4,	  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // released
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_nCS5,	  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // released
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_nCS6,	  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // released
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_nCS7,	  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // GPIO_58/TP pad released
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_CLK,      (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); // GPMC_CLK
    OUTREG32(&pConfig->CONTROL_PADCONF_GPMC_nADV_ALE, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); // GPMC_nADV_ALE
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_nOE,	  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); // GPMC_nOE
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_nWE,	  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); // GPMC_nWE
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_nBE0_CLE, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); // GPMC_nBE0_CLE
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_nBE1,	  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_61 modem power en
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_nWP,	  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); // GPMC_nWP
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_WAIT0,	  (INPUT_ENABLE  | PULL_UP		 | MUX_MODE_0)); // GPMC_WAIT0
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_WAIT1,	  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // released
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_WAIT2,	  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_64 GPS power en
    OUTREG16(&pConfig->CONTROL_PADCONF_GPMC_WAIT3,	  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_65 USB PHY reset
}

//------------------------------------------------------------------------------
//
//  Function:  dss_pads_setup
//
//  Initializes pin/pad mux settings
//
static void dss_pads_setup(void)
{
    OMAP_SYSC_PADCONFS_REGS *pConfig = OALPAtoUA(OMAP_SYSC_PADCONFS_REGS_PA);

	/*DSS*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_PCLK,   (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_PCLK*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_HSYNC,  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_HSYNC*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_VSYNC,  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_VSYNC*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_ACBIAS, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_ACBIAS*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA0,  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA0*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA1,  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA1*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA2,  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA2*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA3,  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA3*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA4,  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA4*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA5,  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA5*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA6,  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA6*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA7,  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA7*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA8,  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA8*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA9,  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA9*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA10, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA10*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA11, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA11*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA12, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA12*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA13, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA13*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA14, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA14*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA15, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA15*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA16, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA16*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA17, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA17*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA18, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA18*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA19, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA19*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA20, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA20*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA21, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA21*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA22, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA22*/
    OUTREG16(&pConfig->CONTROL_PADCONF_DSS_DATA23, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*DSS_DATA23*/
}

//------------------------------------------------------------------------------
//
//  Function:  camera_pads_setup
//
//  Initializes pin/pad mux settings
//
static void camera_pads_setup(void)
{
    OMAP_SYSC_PADCONFS_REGS *pConfig = OALPAtoUA(OMAP_SYSC_PADCONFS_REGS_PA);

	/*CAMERA*/
	OUTREG16(&pConfig->CONTROL_PADCONF_CAM_HS ,    (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_94 Automotive out
    OUTREG16(&pConfig->CONTROL_PADCONF_CAM_VS ,    (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_95 WiFi en
    OUTREG16(&pConfig->CONTROL_PADCONF_CAM_FLD,    (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_98 SOFT_SW_nOFF
    OUTREG16(&pConfig->CONTROL_PADCONF_CAM_XCLKA,  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_96 Dallas
    OUTREG16(&pConfig->CONTROL_PADCONF_CAM_PCLK,   (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_97 Dallas
    OUTREG16(&pConfig->CONTROL_PADCONF_CAM_D0,     (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // GPIO_99/TP released
    OUTREG16(&pConfig->CONTROL_PADCONF_CAM_D1,     (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // GPIO_100/TP released
	OUTREG16(&pConfig->CONTROL_PADCONF_CAM_D2,     (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // GPIO_101/TP released
	OUTREG16(&pConfig->CONTROL_PADCONF_CAM_D3,     (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_102 Automotive input sampled
    OUTREG16(&pConfig->CONTROL_PADCONF_CAM_D4,     (INPUT_ENABLE  | PULL_UP		  | MUX_MODE_4)); // GPIO_103 touch irq
    OUTREG16(&pConfig->CONTROL_PADCONF_CAM_D5,	   (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_104 DISP_BUF_EN
    OUTREG16(&pConfig->CONTROL_PADCONF_CAM_D6,     (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // GPIO_105/TP released
    OUTREG16(&pConfig->CONTROL_PADCONF_CAM_D7,     (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // GPIO_106/TP released
    OUTREG16(&pConfig->CONTROL_PADCONF_CAM_D8,     (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // GPIO_107/TP released
    OUTREG16(&pConfig->CONTROL_PADCONF_CAM_D9,     (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // GPIO_108/TP released
    OUTREG16(&pConfig->CONTROL_PADCONF_CAM_D10,	   (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_109 MMC1_WP
    OUTREG16(&pConfig->CONTROL_PADCONF_CAM_D11,    (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // GPIO_110/TP released
    OUTREG16(&pConfig->CONTROL_PADCONF_CAM_XCLKB,  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_111 HSUSB PHY 1.8 V
    OUTREG16(&pConfig->CONTROL_PADCONF_CAM_WEN,	   (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_167 MCU power off/reset
    OUTREG16(&pConfig->CONTROL_PADCONF_CAM_STROBE, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_126 Power too low
    OUTREG16(&pConfig->CONTROL_PADCONF_CSI2_DX0,   (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // released
    OUTREG16(&pConfig->CONTROL_PADCONF_CSI2_DY0,   (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // released
    OUTREG16(&pConfig->CONTROL_PADCONF_CSI2_DX1,   (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // released
    OUTREG16(&pConfig->CONTROL_PADCONF_CSI2_DY1,   (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // released
}

//------------------------------------------------------------------------------
//
//  Function:  mcbsp_pads_setup
//
//  Initializes pin/pad mux settings
//
static void mcbsp_pads_setup(void)
{
    OMAP_SYSC_PADCONFS_REGS   *pConfig = OALPAtoUA(OMAP_SYSC_PADCONFS_REGS_PA);

	// mcbsp1
	OUTREG16(&pConfig->CONTROL_PADCONF_MCBSP1_CLKR, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4));  // GPIO_156 touch busy
    OUTREG16(&pConfig->CONTROL_PADCONF_MCBSP1_FSR,	(INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7));	// GPIO_157/TP released
	OUTREG16(&pConfig->CONTROL_PADCONF_MCBSP1_DX,	(INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7));	// GPIO_158/TP released
    OUTREG16(&pConfig->CONTROL_PADCONF_MCBSP1_DR,	(INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7));	// GPIO_159/TP released
    OUTREG16(&pConfig->CONTROL_PADCONF_MCBSP_CLKS,  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7));  // GPIO_160/TP released
    OUTREG16(&pConfig->CONTROL_PADCONF_MCBSP1_FSX,	(INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));	// GPIO_161 MIC_SWITCH
    OUTREG16(&pConfig->CONTROL_PADCONF_MCBSP1_CLKX, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4));	// GPIO_162 RS232 transceiver FORCEON
    OUTREG16(&pConfig->CONTROL_PADCONF_MCBSP2_FSX,	(INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0));  // MCBSP2_FSX TPS65950 I2S.SYNC
    OUTREG16(&pConfig->CONTROL_PADCONF_MCBSP2_CLKX, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0));  // MCBSP2_CLKX TPS65950 I2S.CLK
    OUTREG16(&pConfig->CONTROL_PADCONF_MCBSP2_DR,   (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0));  // MCBSP2_DR TPS65950 I2S.DOUT
    OUTREG16(&pConfig->CONTROL_PADCONF_MCBSP2_DX,   (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0));  // MCBSP2_DX TPS65950 I2S.DIN
    OUTREG16(&pConfig->CONTROL_PADCONF_MCBSP3_DX,   (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_1));  // UART2_CTS BT
    OUTREG16(&pConfig->CONTROL_PADCONF_MCBSP3_DR,   (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_1));  // UART2_RTS BT
	OUTREG16(&pConfig->CONTROL_PADCONF_MCBSP3_CLKX,	(INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_1));  // UART2_TX BT
    OUTREG16(&pConfig->CONTROL_PADCONF_MCBSP3_FSX,  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_1));  // UART2_RX BT
	OUTREG16(&pConfig->CONTROL_PADCONF_MCBSP4_CLKX,	(INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0));  // MCBSP4_CLKX MODEM_DVI_CLK
    OUTREG16(&pConfig->CONTROL_PADCONF_MCBSP4_DR,	(INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0));  // MCBSP4_DR MODEM_DVI_TX
    OUTREG16(&pConfig->CONTROL_PADCONF_MCBSP4_DX,	(INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0));  // MCBSP4_DX MODEM_DVI_RX
    OUTREG16(&pConfig->CONTROL_PADCONF_MCBSP4_FSX,	(INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0));  // MCBSP4_FSX MODEM_DVI_SYNC
}

//------------------------------------------------------------------------------
//
//  Function:  uart_pads_setup
//
//  Initializes pin/pad mux settings
//
static void uart_pads_setup(void)
{
    OMAP_SYSC_PADCONFS_REGS   *pConfig = OALPAtoUA(OMAP_SYSC_PADCONFS_REGS_PA);

    OUTREG16(&pConfig->CONTROL_PADCONF_UART1_TX,	   (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*UART1_TX*/
    OUTREG16(&pConfig->CONTROL_PADCONF_UART1_RTS,	   (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*UART1_RTS*/
    OUTREG16(&pConfig->CONTROL_PADCONF_UART1_CTS,	   (INPUT_ENABLE  | PULL_UP		  | MUX_MODE_0)); /*UART1_CTS*/
    OUTREG16(&pConfig->CONTROL_PADCONF_UART1_RX,	   (INPUT_ENABLE  | PULL_UP		  | MUX_MODE_0)); /*UART1_RX*/
    OUTREG16(&pConfig->CONTROL_PADCONF_UART2_CTS,	   (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_144 GPS power en
    OUTREG16(&pConfig->CONTROL_PADCONF_UART2_RTS,	   (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_145 GPS reset
    OUTREG16(&pConfig->CONTROL_PADCONF_UART2_TX,	   (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_146 GPS boot
    OUTREG16(&pConfig->CONTROL_PADCONF_UART2_RX,	   (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_147 GPS status
    OUTREG16(&pConfig->CONTROL_PADCONF_UART3_CTS_RCTX, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // GPIO_163/TP released
    OUTREG16(&pConfig->CONTROL_PADCONF_UART3_RTS_SD,   (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_164 DISP_PWR_EN
    OUTREG16(&pConfig->CONTROL_PADCONF_UART3_RX_IRRX,  (INPUT_ENABLE  | PULL_UP		  | MUX_MODE_0)); /*UART3_RX_IRRX*/
    OUTREG16(&pConfig->CONTROL_PADCONF_UART3_TX_IRTX,  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); /*UART3_TX_IRTX*/
}

//------------------------------------------------------------------------------
//
//  Function:  mmc_pads_setup
//
//  Initializes pin/pad mux settings
//
static void mmc_pads_setup(void)
{
    OMAP_SYSC_PADCONFS_REGS   *pConfig = OALPAtoUA(OMAP_SYSC_PADCONFS_REGS_PA);

    OUTREG16(&pConfig->CONTROL_PADCONF_MMC1_CLK,  (INPUT_DISABLE | PULL_UP		 | MUX_MODE_0)); /*MMC1_CLK*/
    OUTREG16(&pConfig->CONTROL_PADCONF_MMC1_CMD,  (INPUT_ENABLE  | PULL_UP		 | MUX_MODE_0)); /*MMC1_CMD*/
    OUTREG16(&pConfig->CONTROL_PADCONF_MMC1_DAT0, (INPUT_ENABLE  | PULL_UP		 | MUX_MODE_0)); /*MMC1_DAT0*/
    OUTREG16(&pConfig->CONTROL_PADCONF_MMC1_DAT1, (INPUT_ENABLE  | PULL_UP		 | MUX_MODE_0)); /*MMC1_DAT1*/
    OUTREG16(&pConfig->CONTROL_PADCONF_MMC1_DAT2, (INPUT_ENABLE  | PULL_UP		 | MUX_MODE_0)); /*MMC1_DAT2*/
    OUTREG16(&pConfig->CONTROL_PADCONF_MMC1_DAT3, (INPUT_ENABLE  | PULL_UP		 | MUX_MODE_0)); /*MMC1_DAT3*/
    OUTREG16(&pConfig->CONTROL_PADCONF_MMC2_CLK,  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_7)); // MMC2_CLK
    OUTREG16(&pConfig->CONTROL_PADCONF_MMC2_CMD,  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_7)); // MMC2_CMD
    OUTREG16(&pConfig->CONTROL_PADCONF_MMC2_DAT0, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_7)); // MMC2_DAT0
    OUTREG16(&pConfig->CONTROL_PADCONF_MMC2_DAT1, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_7)); // MMC2_DAT1
    OUTREG16(&pConfig->CONTROL_PADCONF_MMC2_DAT2, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_7)); // MMC2_DAT2
    OUTREG16(&pConfig->CONTROL_PADCONF_MMC2_DAT3, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_7)); // MMC2_DAT3
    OUTREG16(&pConfig->CONTROL_PADCONF_MMC2_DAT4, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_136 WIFI_PWR_EN
    OUTREG16(&pConfig->CONTROL_PADCONF_MMC2_DAT5, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_137 BT_EN
    OUTREG16(&pConfig->CONTROL_PADCONF_MMC2_DAT6, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_138 WIFI_EN
    OUTREG16(&pConfig->CONTROL_PADCONF_MMC2_DAT7, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_139 WLAN_nIRQ
}

//------------------------------------------------------------------------------
//
//  Function:  hsusb_pads_setup
//
//  Initializes pin/pad mux settings
//
static void hsusb_pads_setup(void)
{
    OMAP_SYSC_PADCONFS_REGS   *pConfig = OALPAtoUA(OMAP_SYSC_PADCONFS_REGS_PA);

    OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_CLK,   (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*HSUSB0_CLK*/
    OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_STP,   (INPUT_DISABLE | PULL_UP		| MUX_MODE_0)); /*HSUSB0_STP*/
    OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DIR,   (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*HSUSB0_DIR*/
    OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_NXT,   (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*HSUSB0_NXT*/
    OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA0, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*HSUSB0_DATA0*/
    OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA1, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*HSUSB0_DATA1*/
    OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA2, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*HSUSB0_DATA2*/
    OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA3, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*HSUSB0_DATA3*/
    OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA4, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*HSUSB0_DATA4*/
    OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA5, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*HSUSB0_DATA5*/
    OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA6, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*HSUSB0_DATA6*/
    OUTREG16(&pConfig->CONTROL_PADCONF_HSUSB0_DATA7, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); /*HSUSB0_DATA7*/
}

//------------------------------------------------------------------------------
//
//  Function:  mcspi_pads_setup
//
//  Initializes pin/pad mux settings
//
static void mcspi_pads_setup(void)
{
    OMAP_SYSC_PADCONFS_REGS   *pConfig = OALPAtoUA(OMAP_SYSC_PADCONFS_REGS_PA);

    OUTREG16(&pConfig->CONTROL_PADCONF_MCSPI1_CLK, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); // MCSPI1_CLK touch
    OUTREG16(&pConfig->CONTROL_PADCONF_MCSPI1_SIMO,(INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); // MCSPI1_SIMO touch
    OUTREG16(&pConfig->CONTROL_PADCONF_MCSPI1_SOMI,(INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); // MCSPI1_SOMI touch
    OUTREG16(&pConfig->CONTROL_PADCONF_MCSPI1_CS0, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); // MCSPI1_CS0 touch
	OUTREG16(&pConfig->CONTROL_PADCONF_MCSPI1_CS1, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_175 int spkr shutdown
    OUTREG16(&pConfig->CONTROL_PADCONF_MCSPI1_CS2, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_176 ext spkr shutdown
    OUTREG16(&pConfig->CONTROL_PADCONF_MCSPI1_CS3, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_177 I2C3_OE
	OUTREG16(&pConfig->CONTROL_PADCONF_MCSPI2_CLK, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); // MCSPI2_CLK CAN
    OUTREG16(&pConfig->CONTROL_PADCONF_MCSPI2_SIMO,(INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); // MCSPI2_SIMO CAN
    OUTREG16(&pConfig->CONTROL_PADCONF_MCSPI2_SOMI,(INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); // MCSPI2_SOMI CAN
	OUTREG16(&pConfig->CONTROL_PADCONF_MCSPI2_CS0, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); // MCSPI2_CS0 CAN
    OUTREG16(&pConfig->CONTROL_PADCONF_MCSPI2_CS1, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // GPIO_182/TP released
}

//------------------------------------------------------------------------------
//
//  Function:  etk_pads_setup
//
//  Initializes pin/pad mux settings
//
static void etk_pads_setup(void)
{
    OMAP_SYSC_PADCONFS_REGS   *pConfig = OALPAtoUA(OMAP_SYSC_PADCONFS_REGS_PA);

    OUTREG16(&pConfig->CONTROL_PADCONF_ETK_CLK, (INPUT_DISABLE | PULL_UP       | MUX_MODE_3)); // HSUSB1_STP
    OUTREG16(&pConfig->CONTROL_PADCONF_ETK_CTL, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_3)); // HSUSB1_CLK
    OUTREG16(&pConfig->CONTROL_PADCONF_ETK_D0,  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_3)); // HSUSB1_DATA0
    OUTREG16(&pConfig->CONTROL_PADCONF_ETK_D1,  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_3)); // HSUSB1_DATA1
    OUTREG16(&pConfig->CONTROL_PADCONF_ETK_D2,  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_3)); // HSUSB1_DATA2
    OUTREG16(&pConfig->CONTROL_PADCONF_ETK_D3,  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_3)); // HSUSB1_DATA7
    OUTREG16(&pConfig->CONTROL_PADCONF_ETK_D4,  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_3)); // HSUSB1_DATA4
    OUTREG16(&pConfig->CONTROL_PADCONF_ETK_D5,  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_3)); // HSUSB1_DATA5
    OUTREG16(&pConfig->CONTROL_PADCONF_ETK_D6,  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_3)); // HSUSB1_DATA6
    OUTREG16(&pConfig->CONTROL_PADCONF_ETK_D7,  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_3)); // HSUSB1_DATA3
    OUTREG16(&pConfig->CONTROL_PADCONF_ETK_D8,  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_3)); // HSUSB1_DIR
    OUTREG16(&pConfig->CONTROL_PADCONF_ETK_D9,  (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_3)); // HSUSB1_NXT
    OUTREG16(&pConfig->CONTROL_PADCONF_ETK_D10, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_24 MCU_CPU_IRQ
    OUTREG16(&pConfig->CONTROL_PADCONF_ETK_D11, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // GPIO_25/TP released
    OUTREG16(&pConfig->CONTROL_PADCONF_ETK_D12, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // GPIO_26/TP released
    OUTREG16(&pConfig->CONTROL_PADCONF_ETK_D13, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_27 V3P3V_SW_OFF
    OUTREG16(&pConfig->CONTROL_PADCONF_ETK_D14, (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_28 MCU RESUME_ON
    OUTREG16(&pConfig->CONTROL_PADCONF_ETK_D15, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // GPIO_29/TP released
}

//------------------------------------------------------------------------------
//
//  Function:  i2c_pads_setup
//
//  Initializes pin/pad mux settings
//
static void i2c_pads_setup(void)
{
    OMAP_SYSC_PADCONFS_REGS		 *pConfig		= OALPAtoUA(OMAP_SYSC_PADCONFS_REGS_PA);
    OMAP_SYSC_PADCONFS_WKUP_REGS *pWakeupConfig = OALPAtoUA(OMAP_SYSC_PADCONFS_WKUP_REGS_PA);

    OUTREG16(&pConfig->CONTROL_PADCONF_I2C1_SCL,	   (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); // I2C1_SCL TPS65950 control
    OUTREG16(&pConfig->CONTROL_PADCONF_I2C1_SDA,	   (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); // I2C1_SDA TPS65950 control
    OUTREG16(&pConfig->CONTROL_PADCONF_I2C2_SCL,	   (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); // I2C2_SCL MCU
    OUTREG16(&pConfig->CONTROL_PADCONF_I2C2_SDA,	   (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); // I2C2_SDA MCU
    OUTREG16(&pConfig->CONTROL_PADCONF_I2C3_SCL,	   (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); // I2C3_SCL touch cap/usb hub
    OUTREG16(&pConfig->CONTROL_PADCONF_I2C3_SDA,	   (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); // I2C3_SDA touch cap/usb hub
    OUTREG16(&pWakeupConfig->CONTROL_PADCONF_I2C4_SCL, (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); // I2C4_SCL TPS65950 SR
    OUTREG16(&pWakeupConfig->CONTROL_PADCONF_I2C4_SDA, (INPUT_ENABLE | PULL_INACTIVE | MUX_MODE_0)); // I2C4_SDA TPS65950 SR
    
}

//------------------------------------------------------------------------------
//
//  Function:  misc_pads_setup
//
//  Initializes pin/pad mux settings
//
static void misc_pads_setup(void)
{
    OMAP_SYSC_PADCONFS_REGS			   *pConfig			   = OALPAtoUA(OMAP_SYSC_PADCONFS_REGS_PA);
    OMAP_SYSC_PADCONFS_WKUP_REGS	   *pWakeupConfig	   = OALPAtoUA(OMAP_SYSC_PADCONFS_WKUP_REGS_PA);
    OMAP_SYSC_GENERAL_WKUP_REGS_DM3730 *pGeneralWakeupRegs = OALPAtoUA(OMAP_SYSC_GENERAL_WKUP_REGS_DM3730_PA);

    OUTREG16(&pConfig->CONTROL_PADCONF_SYS_NIRQ,		   (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_0 TPS65950 SYS_nIRQ
    OUTREG16(&pConfig->CONTROL_PADCONF_HDQ_SIO,			   (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_7)); // GPIO_170/TP released
    OUTREG16(&pConfig->CONTROL_PADCONF_SYS_CLKOUT2,		   (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_4)); // GPIO_186 MCU POWER_TMR_ON
    OUTREG16(&pConfig->CONTROL_PADCONF_GPIO129,			   (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); // GPIO_129 MODEM_PWR_STATUS
    OUTREG16(&pWakeupConfig->CONTROL_PADCONF_SYS_32K,	   (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); // SYS_32K
    OUTREG16(&pWakeupConfig->CONTROL_PADCONF_SYS_CLKREQ,   (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); // SYS_CLKREQ
    OUTREG16(&pWakeupConfig->CONTROL_PADCONF_SYS_BOOT0,	   (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_2
    OUTREG16(&pWakeupConfig->CONTROL_PADCONF_SYS_BOOT1,    (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_3
    OUTREG16(&pWakeupConfig->CONTROL_PADCONF_SYS_BOOT2,    (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_4
    OUTREG16(&pWakeupConfig->CONTROL_PADCONF_SYS_BOOT3,    (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_5
    OUTREG16(&pWakeupConfig->CONTROL_PADCONF_SYS_BOOT4,    (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_6
    OUTREG16(&pWakeupConfig->CONTROL_PADCONF_SYS_BOOT5,	   (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_7
    OUTREG16(&pWakeupConfig->CONTROL_PADCONF_SYS_BOOT6,    (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_4)); // GPIO_8
    OUTREG16(&pWakeupConfig->CONTROL_PADCONF_SYS_OFF_MODE, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); // SYS_OFF_MODE
	OUTREG16(&pWakeupConfig->CONTROL_PADCONF_SYS_CLKOUT1,  (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); // SYS_CLKOUT1
    OUTREG16(&pWakeupConfig->CONTROL_PADCONF_JTAG_NTRST,   (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); // JTAG_nTRST
    OUTREG16(&pWakeupConfig->CONTROL_PADCONF_JTAG_TCK,     (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); // JTAG_TCK
    OUTREG16(&pWakeupConfig->CONTROL_PADCONF_JTAG_TMS,	   (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); // JTAG_TMS
    OUTREG16(&pWakeupConfig->CONTROL_PADCONF_JTAG_TDI,	   (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); // JTAG_TDI
    OUTREG16(&pWakeupConfig->CONTROL_PADCONF_JTAG_EMU0,	   (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); // JTAG_EMU0
    OUTREG16(&pWakeupConfig->CONTROL_PADCONF_JTAG_EMU1,    (INPUT_ENABLE  | PULL_INACTIVE | MUX_MODE_0)); // JTAG_EMU1

    // disable I2C1, I2C2 and I2C4 internal pullups, set MMC1 max speed to 52MHz
    OUTREG32(&pGeneralWakeupRegs->CONTROL_PROG_IO_WKUP1,   PRG_SR_PULLUPRESX | PRG_I2C1_PULLUPRESX | PRG_I2C2_PULLUPRESX | PRG_SDMMC1_SPEEDCTRL);
	// enable bandgap
    OUTREG32(&pGeneralWakeupRegs->CONTROL_BGAPTS_WKUP,	   PRG_BGPOFF_LB);
}

//------------------------------------------------------------------------------
//
//  Function:  pads_setup
//
//  Initializes pin/pad mux settings
//
static VOID pads_setup()
{
	sdrc_pads_setup();
	gpmc_pads_setup();
    dss_pads_setup();
	camera_pads_setup();
	mcbsp_pads_setup();
	uart_pads_setup();
    mmc_pads_setup();
    hsusb_pads_setup(); // OTG to TPS65950 PHY
	mcspi_pads_setup();
	i2c_pads_setup();
	misc_pads_setup();
    // 12 pin ULPI transceiver, configure USB port1 pins for ULPI PHY mode
    // Note that this port configuration is only supported by the EHCI driver.
	etk_pads_setup();
}

//------------------------------------------------------------------------------
//
//  Function:  gpio_setup
//
//  Initializes GPIO pin direction/state.  
//
static void gpio_setup()
{
    OMAP_GPIO_REGS		   *pGpio;
    OMAP_PRCM_PER_CM_REGS  *pPrcmPerCM = OALPAtoUA(OMAP_PRCM_PER_CM_REGS_PA);
    OMAP_PRCM_WKUP_CM_REGS *pPrcmWkupCM = OALPAtoUA(OMAP_PRCM_WKUP_CM_REGS_PA);

    // enable all GPIO clocks and also GPTIMER1 (used by OAL I2C driver)
    SETREG32(&pPrcmWkupCM->CM_FCLKEN_WKUP, CM_CLKEN_GPT1 | CM_CLKEN_GPIO1);
    SETREG32(&pPrcmWkupCM->CM_ICLKEN_WKUP, CM_CLKEN_GPT1 | CM_CLKEN_GPIO1);
    SETREG32(&pPrcmPerCM->CM_FCLKEN_PER,   CM_CLKEN_GPIO2 | CM_CLKEN_GPIO3 | CM_CLKEN_GPIO4 | CM_CLKEN_GPIO5 | CM_CLKEN_GPIO6);
    SETREG32(&pPrcmPerCM->CM_ICLKEN_PER,   CM_CLKEN_GPIO2 | CM_CLKEN_GPIO3 | CM_CLKEN_GPIO4 | CM_CLKEN_GPIO5 | CM_CLKEN_GPIO6);
    
    // Initialize state/direction for all pins configured as gpio
    // Bank 1 GPIO  0..31 nothing to do

	// Bank 2 GPIO 32..63
	// GPIO_27 V3P3V_SW_OFF 0
	// GPIO_34 USB hub reset 0
	// GPIO_38 CAN en 0
	// GPIO_40 modem reset 0
	// GPIO_41 modem en 0
	// GPIO_42 capacitive touch reset 0
	// GPIO_43 CAN power en 0
	// GPIO_61 modem power en 0
	pGpio = OALPAtoUA(OMAP_GPIO2_REGS_PA);
	OUTREG32(&pGpio->DATAOUT, ~(BIT2 | BIT6 | BIT8 | BIT9 | BIT10 | BIT11 | BIT27 | BIT29));
    OUTREG32(&pGpio->OE,	  ~(BIT2 | BIT6 | BIT8 | BIT9 | BIT10 | BIT11 | BIT27 | BIT29));
    
    // Bank 3 GPIO 64..95
    // GPIO_64 GPS power en 0
    // GPIO_65 USB PHY reset 0
	// GPIO_94 Aotomotive out 0
    pGpio = OALPAtoUA(OMAP_GPIO3_REGS_PA);
	OUTREG32(&pGpio->DATAOUT, ~(BIT0 | BIT1 | BIT30));
    OUTREG32(&pGpio->OE,	  ~(BIT0 | BIT1 | BIT30));

    // Bank 4 GPIO 96..127
    // GPIO_97 Dallas 0
    // GPIO_98 SOFT_SW_nOFF 0
    // GPIO_104 DISP_BUF_EN 1
    // GPIO_111 HSUSB PHY 1.8 V 1
    pGpio = OALPAtoUA(OMAP_GPIO4_REGS_PA);
	OUTREG32(&pGpio->DATAOUT, ~(BIT1 | BIT2));
	OUTREG32(&pGpio->OE, ~(BIT1 | BIT2 | BIT8 | BIT15));
    
    // Bank 5 GPIO 128..159
    // GPIO_136 WIFI_PWR_EN 0
    // GPIO_137 BT_EN 0
    // GPIO_138 WIFI_EN 0
    // GPIO_144 GPS power en 0
    // GPIO_145 GPS reset 0
    // GPIO_146 GPS boot 0
	pGpio = OALPAtoUA(OMAP_GPIO5_REGS_PA);
    OUTREG32(&pGpio->DATAOUT, 0);
    OUTREG32(&pGpio->OE, ~(BIT8 | BIT9 | BIT10 | BIT16 | BIT17 | BIT18));
    
    // Bank 6 GPIO 160..192
	// GPIO_161 MIC_SWITCH 0
	// GPIO_162 RS232 transceiver FORCEON 0
	// GPIO_164 DISP_PWR_EN 0
	// GPIO_175 int spkr shutdown 0
    // GPIO_176 ext spkr shutdown 0
    // GPIO_177 I2C3_OE 0
    // GPIO_186 MCU POWER_TMR_ON 0
    pGpio = OALPAtoUA(OMAP_GPIO6_REGS_PA);
    OUTREG32(&pGpio->DATAOUT, 0);
    OUTREG32(&pGpio->OE, ~(BIT1 | BIT2 | BIT4 | BIT15 | BIT16 | BIT17 | BIT26));
}


//------------------------------------------------------------------------------
//
//  Function:  clocks_setup
//
//  Initializes clocks and power. No global variables allowed.
//
static void clocks_setup(UINT32 opm)
{
    unsigned int val;
    OMAP_PRCM_EMU_CM_REGS			 *pPrcmEmuCM  = OALPAtoUA(OMAP_PRCM_EMU_CM_REGS_PA);
    OMAP_PRCM_CAM_CM_REGS			 *pPrcmCamCM  = OALPAtoUA(OMAP_PRCM_CAM_CM_REGS_PA);
    OMAP_PRCM_DSS_CM_REGS			 *pPrcmDssCM  = OALPAtoUA(OMAP_PRCM_DSS_CM_REGS_PA);
    OMAP_PRCM_PER_CM_REGS			 *pPrcmPerCM  = OALPAtoUA(OMAP_PRCM_PER_CM_REGS_PA);
    OMAP_PRCM_SGX_CM_REGS			 *pPrcmSgxCM  = OALPAtoUA(OMAP_PRCM_SGX_CM_REGS_PA);
    OMAP_PRCM_MPU_CM_REGS			 *pPrcmMpuCM  = OALPAtoUA(OMAP_PRCM_MPU_CM_REGS_PA);
    OMAP_PRCM_IVA2_CM_REGS			 *pPrcmIvaCM  = OALPAtoUA(OMAP_PRCM_IVA2_CM_REGS_PA);
    OMAP_PRCM_CORE_CM_REGS			 *pPrcmCoreCM = OALPAtoUA(OMAP_PRCM_CORE_CM_REGS_PA);
    OMAP_PRCM_WKUP_CM_REGS			 *pPrcmWkupCM = OALPAtoUA(OMAP_PRCM_WKUP_CM_REGS_PA);
    OMAP_PRCM_CLOCK_CONTROL_CM_REGS	 *pPrcmClkCM  = OALPAtoUA(OMAP_PRCM_CLOCK_CONTROL_CM_REGS_PA);
    OMAP_PRCM_CLOCK_CONTROL_PRM_REGS *pPrcmClkPRM = OALPAtoUA(OMAP_PRCM_CLOCK_CONTROL_PRM_REGS_PA);

    // setup input system clock
    OUTREG32(&pPrcmClkPRM->PRM_CLKSEL, BSP_PRM_CLKSEL);

    //---------------------------------------------------------------------------------------------
    // setup dpll timings for core and peripheral dpll
    //
    // configure clock ratios for L3, L4, FSHOSTUSB, SSI configure clock selection for gpt10, gpt11
	//
    OUTREG32(&pPrcmCoreCM->CM_CLKSEL_CORE, BSP_CM_CLKSEL_CORE);
    
    // configure clock ratios as well as frequency selection for core dpll
	//
    OUTREG32(&pPrcmClkCM->CM_CLKSEL1_PLL, BSP_CM_CLKSEL1_PLL);

    // configure timings for all related peripherals
	//
    OUTREG32(&pPrcmEmuCM->CM_CLKSEL1_EMU, BSP_CM_CLKSEL1_EMU);
    OUTREG32(&pPrcmCamCM->CM_CLKSEL_CAM,  BSP_CM_CLKSEL_CAM);
    OUTREG32(&pPrcmDssCM->CM_CLKSEL_DSS,  BSP_CM_CLKSEL_DSS);
    OUTREG32(&pPrcmClkCM->CM_CLKSEL3_PLL, BSP_CM_CLKSEL3_PLL);
    OUTREG32(&pPrcmClkCM->CM_CLKSEL2_PLL, BSP_CM_CLKSEL2_PLL);
    OUTREG32(&pPrcmSgxCM->CM_CLKSEL_SGX,  BSP_CM_CLKSEL_SGX);

    // lock dpll with correct frequency selection
    OUTREG32(&pPrcmClkCM->CM_CLKEN_PLL, BSP_CM_CLKEN_PLL);
    while((INREG32(&pPrcmClkCM->CM_IDLEST_CKGEN) & DPLL_STATUS_MASK) != DPLL_STATUS_LOCKED);

    //---------------------------------
    // setup dpll timings for mpu dpll
    //
    // put mpu dpll1 in bypass
	//
    val  = INREG32(&pPrcmMpuCM->CM_CLKEN_PLL_MPU);
    val &= ~DPLL_MODE_MASK;
    val |= DPLL_MODE_LOWPOWER_BYPASS;
    OUTREG32(&pPrcmMpuCM->CM_CLKEN_PLL_MPU, val);
    while ((INREG32(&pPrcmMpuCM->CM_IDLEST_PLL_MPU) & DPLL_STATUS_MASK) != DPLL_STATUS_BYPASSED);

    // setup DPLL1 divider
    OUTREG32(&pPrcmMpuCM->CM_CLKSEL2_PLL_MPU, BSP_CM_CLKSEL2_PLL_MPU);
    
    // configure clock ratios as well as frequency selection for mpu dpll
	//
	if(4 == opm)
		val = BSP_CM_CLKSEL1_PLL_MPU_1000;
	else if(3 == opm)
		val = BSP_CM_CLKSEL1_PLL_MPU_800;
	else
		val = BSP_CM_CLKSEL1_PLL_MPU_600;
    OUTREG32(&pPrcmMpuCM->CM_CLKSEL1_PLL_MPU, val);

    // lock dpll1 with correct frequency selection
	//
    OUTREG32(&pPrcmMpuCM->CM_CLKEN_PLL_MPU, BSP_CM_CLKEN_PLL_MPU);
    while((INREG32(&pPrcmMpuCM->CM_IDLEST_PLL_MPU) & DPLL_STATUS_MASK) != DPLL_STATUS_LOCKED);
    
    //---------------------------------
    // setup dpll timings for iva2 dpll
    //
    // put iva2 dpll2 in bypass
	//
    val = INREG32(&pPrcmIvaCM->CM_CLKEN_PLL_IVA2);

    val &= ~DPLL_MODE_MASK;
    val |= DPLL_MODE_LOWPOWER_BYPASS;
    OUTREG32(&pPrcmIvaCM->CM_CLKEN_PLL_IVA2, val);
    while((INREG32(&pPrcmIvaCM->CM_IDLEST_PLL_IVA2) & DPLL_STATUS_MASK) != DPLL_STATUS_BYPASSED);
		
    // setup DPLL2 divider
	//
    OUTREG32(&pPrcmIvaCM->CM_CLKSEL2_PLL_IVA2, BSP_CM_CLKSEL2_PLL_IVA2);
    
    // configure clock ratios as well as frequency selection for iva dpll
	//
	if(4 == opm)
		val = BSP_CM_CLKSEL1_PLL_IVA2_874;
	else if(3 == opm)
		val = BSP_CM_CLKSEL1_PLL_IVA2_660;
	else
		val = BSP_CM_CLKSEL1_PLL_IVA2_520;
    OUTREG32(&pPrcmIvaCM->CM_CLKSEL1_PLL_IVA2, val);

    // lock dpll2 with correct frequency selection
	//
    OUTREG32(&pPrcmIvaCM->CM_CLKEN_PLL_IVA2, BSP_CM_CLKEN_PLL_IVA2);
    while((INREG32(&pPrcmIvaCM->CM_IDLEST_PLL_IVA2) & DPLL_STATUS_MASK) != DPLL_STATUS_LOCKED);

    //---------------------------------
    // setup dpll timings for core and peripheral dpll
    //
    // configure clock ratios for 120m
	//
    OUTREG32(&pPrcmClkCM->CM_CLKSEL5_PLL, BSP_CM_CLKSEL5_PLL);
    
    // configure m:n clock ratios as well as frequency selection for core dpll
	//
    OUTREG32(&pPrcmClkCM->CM_CLKSEL4_PLL, BSP_CM_CLKSEL4_PLL);

    // lock dpll with correct frequency selection
	//
    OUTREG32(&pPrcmClkCM->CM_CLKEN2_PLL, BSP_CM_CLKEN2_PLL);
    while((INREG32(&pPrcmClkCM->CM_IDLEST2_CKGEN) & DPLL_STATUS_MASK) != DPLL_STATUS_LOCKED);
    
    //----------------------------------------------------------------------------------------
    // Enable GPTIMER1, GPIO bank 1 (debug led)
    SETREG32(&pPrcmWkupCM->CM_FCLKEN_WKUP, (CM_CLKEN_GPT1|CM_CLKEN_GPIO1));
    SETREG32(&pPrcmWkupCM->CM_ICLKEN_WKUP, (CM_CLKEN_GPT1|CM_CLKEN_GPIO1));

    // Enable UART3 (debug port) and GPIO banks that are accessed in the bootloader
	//
    SETREG32(&pPrcmPerCM->CM_FCLKEN_PER, (CM_CLKEN_UART3|CM_CLKEN_GPIO6|CM_CLKEN_GPIO5|CM_CLKEN_GPIO3));
    SETREG32(&pPrcmPerCM->CM_ICLKEN_PER, (CM_CLKEN_UART3|CM_CLKEN_GPIO6|CM_CLKEN_GPIO5|CM_CLKEN_GPIO3));

    // Disable HSUSB OTG interface clock
	//
    CLRREG32(&pPrcmCoreCM->CM_ICLKEN1_CORE, CM_CLKEN_HSOTGUSB);

    // Disable D2D interface clock
	//
    CLRREG32(&pPrcmCoreCM->CM_ICLKEN1_CORE, CM_CLKEN_D2D);

    // Enable 32K CLK for BANDGAP Temperature Sensor
	//
    OUTREG32(&pPrcmCoreCM->CM_FCLKEN3_CORE, CM_IDLEST_ST_EN_TS|CM_IDLEST_ST_USBTLL);
}


//------------------------------------------------------------------------------
//
//  Function:  UpdateVoltageLevels
//
//  update voltage levels
//
static void UpdateVoltageLevels(UINT32 opm)
{
	UINT32 val;
    OMAP_PRCM_GLOBAL_PRM_REGS* pPrcmGblPRM = OALPAtoUA(OMAP_PRCM_GLOBAL_PRM_REGS_PA);
    //OMAP_PRCM_OCP_SYSTEM_PRM_REGS *pPrcmOcpPRM = OALPAtoUA(OMAP_PRCM_OCP_SYSTEM_PRM_REGS_PA);

    //---------------------------------
    // setup voltage processors
    //

    // setup i2c for smps communication
    OUTREG32(&pPrcmGblPRM->PRM_VC_SMPS_SA, BSP_VC_SMPS_SA_INIT);
    OUTREG32(&pPrcmGblPRM->PRM_VC_SMPS_VOL_RA, BSP_VC_SMPS_VOL_RA_INIT);
    OUTREG32(&pPrcmGblPRM->PRM_VC_SMPS_CMD_RA, BSP_VC_SMPS_CMD_RA_INIT);
    OUTREG32(&pPrcmGblPRM->PRM_VC_CH_CONF, BSP_VC_CH_CONF_INIT);  
    OUTREG32(&pPrcmGblPRM->PRM_VC_I2C_CFG, BSP_PRM_VC_I2C_CFG_INIT);

    // set intial voltage levels
	if(4 == opm)
		val = BSP_PRM_VC_CMD_VAL_0_INIT4;
	else if(3 == opm)
		val = BSP_PRM_VC_CMD_VAL_0_INIT3;
	else
		val = BSP_PRM_VC_CMD_VAL_0_INIT2;
    OUTREG32(&pPrcmGblPRM->PRM_VC_CMD_VAL_0, val);
    OUTREG32(&pPrcmGblPRM->PRM_VC_CMD_VAL_1, BSP_PRM_VC_CMD_VAL_1_INIT);

    // set PowerIC error offset, gains, and initial voltage
	if(4 == opm)
		val = BSP_PRM_VP1_CONFIG_INIT_4;
	else if(3 == opm)
		val = BSP_PRM_VP1_CONFIG_INIT_3;
	else
		val = BSP_PRM_VP1_CONFIG_INIT_2;
    OUTREG32(&pPrcmGblPRM->PRM_VP1_CONFIG, val);
    OUTREG32(&pPrcmGblPRM->PRM_VP2_CONFIG, BSP_PRM_VP2_CONFIG_INIT);

    // set PowerIC slew range
    OUTREG32(&pPrcmGblPRM->PRM_VP1_VSTEPMIN, BSP_PRM_VP1_VSTEPMIN_INIT);
    OUTREG32(&pPrcmGblPRM->PRM_VP1_VSTEPMAX, BSP_PRM_VP1_VSTEPMAX_INIT);
    OUTREG32(&pPrcmGblPRM->PRM_VP2_VSTEPMIN, BSP_PRM_VP2_VSTEPMIN_INIT);
    OUTREG32(&pPrcmGblPRM->PRM_VP2_VSTEPMAX, BSP_PRM_VP2_VSTEPMAX_INIT);

    // set PowerIC voltage limits and timeout
    OUTREG32(&pPrcmGblPRM->PRM_VP1_VLIMITTO, BSP_PRM_VP1_VLIMITTO_INIT);
    OUTREG32(&pPrcmGblPRM->PRM_VP2_VLIMITTO, BSP_PRM_VP2_VLIMITTO_INIT);
    
    // enable voltage processors
    SETREG32(&pPrcmGblPRM->PRM_VP1_CONFIG, SMPS_VPENABLE);
    SETREG32(&pPrcmGblPRM->PRM_VP2_CONFIG, SMPS_VPENABLE);

    // enable timeout
    SETREG32(&pPrcmGblPRM->PRM_VP1_CONFIG, SMPS_TIMEOUTEN);
    SETREG32(&pPrcmGblPRM->PRM_VP2_CONFIG, SMPS_TIMEOUTEN);    

    // flush commands to smps
    SETREG32(&pPrcmGblPRM->PRM_VP1_CONFIG, SMPS_FORCEUPDATE | SMPS_INITVDD);
    SETREG32(&pPrcmGblPRM->PRM_VP2_CONFIG, SMPS_FORCEUPDATE | SMPS_INITVDD);

    // allow voltage to settle
    OALStall(10000);

    // disable voltage processors
    CLRREG32(&pPrcmGblPRM->PRM_VP1_CONFIG, SMPS_VPENABLE);
    CLRREG32(&pPrcmGblPRM->PRM_VP2_CONFIG, SMPS_VPENABLE);
}

//------------------------------------------------------------------------------
//
// Function:  memories_setup
//
// Initializes memory interfaces
// TODO: add HYNIX support
//
#define SDRC_SYSCONFIG_SOFTWARE_RESET       (1 << 1)
static VOID memories_setup(UINT32 mem_tpl)
{
    OMAP_GPMC_REGS* pGpmc = OALPAtoUA(OMAP_GPMC_REGS_PA);
    OMAP_SDRC_REGS* pSdrc = OALPAtoUA(OMAP_SDRC_REGS_PA);
    OMAP_PRCM_GLOBAL_PRM_REGS * pPrmGlobal = OALPAtoUA(OMAP_PRCM_GLOBAL_PRM_REGS_PA);
    OMAP_SYSC_PADCONFS_REGS *pConfig = OALPAtoUA(OMAP_SYSC_PADCONFS_REGS_PA);
    
    unsigned int val = 0;
    BOOL bColdBoot;

    //  Global GPMC Configuration
    OUTREG32(&pGpmc->GPMC_SYSCONFIG,       0x00000008);   // No idle, L3 clock free running      
    OUTREG32(&pGpmc->GPMC_IRQENABLE,       0x00000000);   // All interrupts disabled    
    OUTREG32(&pGpmc->GPMC_TIMEOUT_CONTROL, 0x00000000);   // Time out disabled    
    OUTREG32(&pGpmc->GPMC_CONFIG,          0x00000000);   // WP low, force posted write for NAND    

    // Configure CS0 for NAND,  Base Address 0x08000000
    OUTREG32(&pGpmc->GPMC_CONFIG1_0, BSP_GPMC_NAND_CONFIG1);
    OUTREG32(&pGpmc->GPMC_CONFIG2_0, BSP_GPMC_NAND_CONFIG2);
    OUTREG32(&pGpmc->GPMC_CONFIG3_0, BSP_GPMC_NAND_CONFIG3);
    OUTREG32(&pGpmc->GPMC_CONFIG4_0, BSP_GPMC_NAND_CONFIG4);
    OUTREG32(&pGpmc->GPMC_CONFIG5_0, BSP_GPMC_NAND_CONFIG5);
    OUTREG32(&pGpmc->GPMC_CONFIG6_0, BSP_GPMC_NAND_CONFIG6);
    OUTREG32(&pGpmc->GPMC_CONFIG7_0, BSP_GPMC_NAND_CONFIG7);

    // check global reset status
    val = INREG32(&pPrmGlobal->PRM_RSTST);
	if (val & (GLOBALWARM_RST| EXTERNALWARM_RST | MPU_WD_RST))
        bColdBoot = FALSE;
    else
        bColdBoot = TRUE;
    
    // read config register
    INREG32(&pSdrc->SDRC_SYSCONFIG);

    if(bColdBoot)
    {
        // Disable SDRC power saving mode
        CLRREG32(&pSdrc->SDRC_POWER, SDRC_POWER_PWDENA);

		// update memory cofiguration
		// MT29C4G96MAZBACJG-5 IT only available for JJ module
		//
		OUTREG32(&pSdrc->SDRC_MCFG_0, BSP_SDRC_MCFG_0);
		OUTREG32(&pSdrc->SDRC_MCFG_1, BSP_SDRC_MCFG_1);

		OUTREG32(&pSdrc->SDRC_SHARING, BSP_SDRC_SHARING);

        // wait for at least 200us
        OALStall(2000);

        // set autorefresh
        OUTREG32(&pSdrc->SDRC_RFR_CTRL_0, BSP_SDRC_RFR_CTRL_0);
        OUTREG32(&pSdrc->SDRC_RFR_CTRL_1, BSP_SDRC_RFR_CTRL_1);

		// setup ac timings
		OUTREG32(&pSdrc->SDRC_ACTIM_CTRLA_0, BSP_SDRC_ACTIM_CTRLA_0);
		OUTREG32(&pSdrc->SDRC_ACTIM_CTRLA_1, BSP_SDRC_ACTIM_CTRLA_1);
		OUTREG32(&pSdrc->SDRC_ACTIM_CTRLB_0, BSP_SDRC_ACTIM_CTRLB_0);
		OUTREG32(&pSdrc->SDRC_ACTIM_CTRLB_1, BSP_SDRC_ACTIM_CTRLB_1);

        // manual command sequence to start bank 0
        OUTREG32(&pSdrc->SDRC_MANUAL_0, 0);
        // wait for at least 200us
        OALStall(2000);
        OUTREG32(&pSdrc->SDRC_MANUAL_0, 1);
        OUTREG32(&pSdrc->SDRC_MANUAL_0, 2);
        OUTREG32(&pSdrc->SDRC_MANUAL_0, 2);
        OUTREG32(&pSdrc->SDRC_MR_0, BSP_SDRC_MR_0);
        
        // manual command sequence to start bank 1
        OUTREG32(&pSdrc->SDRC_MANUAL_1, 0);
        // wait for at least 200us
        OALStall(2000);
        OUTREG32(&pSdrc->SDRC_MANUAL_1, 1);
        OUTREG32(&pSdrc->SDRC_MANUAL_1, 2);
        OUTREG32(&pSdrc->SDRC_MANUAL_1, 2);
        OUTREG32(&pSdrc->SDRC_MR_1, BSP_SDRC_MR_1);

        // re-enable power saving mode
        SETREG32(&pSdrc->SDRC_POWER, SDRC_POWER_PWDENA | SDRC_POWER_SRFRONIDLEREQ);

        // update sdrc dll timings
        OUTREG32(&pSdrc->SDRC_DLLA_CTRL, BSP_SDRC_DLLA_CTRL);
        OUTREG32(&pSdrc->SDRC_DLLB_CTRL, BSP_SDRC_DLLB_CTRL);
        
        // update sdram characteristics
        OUTREG32(&pSdrc->SDRC_EMR2_0, BSP_SDRC_EMR2_0);
        OUTREG32(&pSdrc->SDRC_EMR2_1, BSP_SDRC_EMR2_1);
    }
    else
    {
        //After warm reset, the SDRC will be unreliable and this will cause eboot image can't be copied from NAND flash to SDRAM correctly.
        //Therefore, we have to force SDRC to reset after warm reset to solve this issue.
        
         //SDRC reset by software
        OUTREG32(&pSdrc->SDRC_SYSCONFIG, SDRC_SYSCONFIG_SOFTWARE_RESET);
        // wait for at least 1000us
        OALStall(1000);

        //After SDRC reset, we do below steps to configure SDRC regisger again.
         // Disable SDRC power saving mode
        CLRREG32(&pSdrc->SDRC_POWER, SDRC_POWER_PWDENA);

        // update memory cofiguration
		OUTREG32(&pSdrc->SDRC_MCFG_0, BSP_SDRC_MCFG_0);
		OUTREG32(&pSdrc->SDRC_MCFG_1, BSP_SDRC_MCFG_1);

		OUTREG32(&pSdrc->SDRC_SHARING, BSP_SDRC_SHARING);

        // wait for at least 2000us
        OALStall(2000);

        // set autorefresh
        OUTREG32(&pSdrc->SDRC_RFR_CTRL_0, BSP_SDRC_RFR_CTRL_0);
        OUTREG32(&pSdrc->SDRC_RFR_CTRL_1, BSP_SDRC_RFR_CTRL_1);

        // setup ac timings
		OUTREG32(&pSdrc->SDRC_ACTIM_CTRLA_0, BSP_SDRC_ACTIM_CTRLA_0);
		OUTREG32(&pSdrc->SDRC_ACTIM_CTRLA_1, BSP_SDRC_ACTIM_CTRLA_1);
		OUTREG32(&pSdrc->SDRC_ACTIM_CTRLB_0, BSP_SDRC_ACTIM_CTRLB_0);
		OUTREG32(&pSdrc->SDRC_ACTIM_CTRLB_1, BSP_SDRC_ACTIM_CTRLB_1);

        // manual command sequence to start bank 0
        OUTREG32(&pSdrc->SDRC_MANUAL_0, 0);
        // wait for at least 2000us
        OALStall(2000);
        OUTREG32(&pSdrc->SDRC_MANUAL_0, 1);
        OUTREG32(&pSdrc->SDRC_MANUAL_0, 2);
        OUTREG32(&pSdrc->SDRC_MANUAL_0, 2);
        OUTREG32(&pSdrc->SDRC_MR_0, BSP_SDRC_MR_0);
        
        // manual command sequence to start bank 1
        OUTREG32(&pSdrc->SDRC_MANUAL_1, 0);
        // wait for at least 200us
        OALStall(2000);
        OUTREG32(&pSdrc->SDRC_MANUAL_1, 1);
        OUTREG32(&pSdrc->SDRC_MANUAL_1, 2);
        OUTREG32(&pSdrc->SDRC_MANUAL_1, 2);
        OUTREG32(&pSdrc->SDRC_MR_1, BSP_SDRC_MR_1);

		// re-enable power saving mode
        SETREG32(&pSdrc->SDRC_POWER, SDRC_POWER_PWDENA | SDRC_POWER_SRFRONIDLEREQ);

        // update sdrc dll timings
        OUTREG32(&pSdrc->SDRC_DLLA_CTRL, BSP_SDRC_DLLA_CTRL);
        OUTREG32(&pSdrc->SDRC_DLLB_CTRL, BSP_SDRC_DLLB_CTRL);
        
        // update sdram characteristics
        OUTREG32(&pSdrc->SDRC_EMR2_0, BSP_SDRC_EMR2_0);
        OUTREG32(&pSdrc->SDRC_EMR2_1, BSP_SDRC_EMR2_1);
          
        
        // Issue Exit Self Refresh command
        //OUTREG32(&pSdrc->SDRC_MANUAL_0, 6);
    }
    
    SETREG32(&pSdrc->SDRC_POWER, SDRC_POWER_SRFRONRESET);

    // allow SDRC to settle
    OALStall(100);

    // release the force on the clke signals
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_CKE0, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0));
    OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_CKE1, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); 
}

//------------------------------------------------------------------------------
//
//  Function:  PlatformSetup
//
//  Initializes platform settings.  Stack based initialization only - no 
//  global variables allowed.
//
VOID PlatformSetup()
{

    //  Initialize the platform
	//XLDRMSG(TEXT("PlatformSetup: disable watchdog\r\n"));
    disable_watchdog();

	//XLDRMSG(TEXT("PlatformSetup: gpio setup\r\n"));
    gpio_setup();  

	//XLDRMSG(TEXT("PlatformSetup: pads setup\r\n"));
    pads_setup();

//	while(1);

	// TDOD: a2d conversation for board config

	//XLDRMSG(TEXT("PlatformSetup: memory setup\r\n"));
    memories_setup(0);

    // configure i2c devices
    OALI2CInit(OMAP_DEVICE_I2C1, OALPAtoUA(OMAP_I2C1_REGS_PA));
    OALI2CInit(OMAP_DEVICE_I2C2, OALPAtoUA(OMAP_I2C2_REGS_PA));
    OALI2CInit(OMAP_DEVICE_I2C3, OALPAtoUA(OMAP_I2C3_REGS_PA));

    InitTwlPower();
    UpdateVoltageLevels(4);
    clocks_setup(4); 
    //XLDRMSGINIT;

	//XLDRMSG(TEXT("Operation Mode: "));
	//XLDRMSG(L"\r\n");
	*(UINT32 *)IMAGE_SHARE_OPM = 4;
	*(UINT32 *)IMAGE_SHARE_RAM_TOPOLOGY = 0;
}

//------------------------------------------------------------------------------
//
//  Function:  OALGetTickCount()
//
//  stub routine
//
UINT32 OALGetTickCount()
{
    OMAP_GPTIMER_REGS *pGPTimerRegs = OALPAtoUA(OMAP_GPTIMER1_REGS_PA);
    return INREG32(&pGPTimerRegs->TCRR) >> 5;
}