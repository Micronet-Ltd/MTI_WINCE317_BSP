/*---------------------------------------------------------------------------
               ----> DO NOT REMOVE THE FOLLOWING NOTICE <----

                  Copyright (c) 1993 - 2010 Datalight, Inc.
                       All Rights Reserved Worldwide.

  Datalight, Incorporated is a Washington State corporation currently located
  at:
        21520 30th Dr SE, Suite 110,      Tel:  425-951-8086
        Bothell, WA  98021                Fax:  425-951-8094
        USA                               Web:  http://www.datalight.com

  This software, including without limitation all source code and documen-
  tation, is a trade secret and the confidential property of Datalight, 
  Inc., protected under the copyright laws of the United States and other
  jurisdictions.  Patents may be pending.

  U.S. Government Restricted Rights:  Use, duplication, reproduction, or
  transfer of this commercial product and accompanying documentation is
  restricted in accordance with FAR 12.212 and DFARS 227.7202 and by a
  License Agreement.

  IN ADDITION TO COPYRIGHT AND PATENT LAW, THIS SOFTWARE IS PROTECTED UNDER
  CONTRACT(S) BETWEEN DATALIGHT, INC. AND THE LICENSEE ("BINDING AGREEMENTS").
  IF YOU ARE A LICENSEE, YOUR RIGHT, IF ANY, TO COPY, PUBLISH, MODIFY, OR
  OTHERWISE USE THE SOFTWARE, IS SUBJECT TO THE TERMS AND CONDITIONS OF THE
  BINDING AGREEMENTS.  BY USING THE SOFTWARE IN ANY MANNER, IN WHOLE OR IN
  PART, YOU AGREE TO BE BOUND BY THE TERMS OF THE BINDING AGREEMENTS.

  IF YOU ARE NOT A DATALIGHT LICENSEE, ANY USE MAY RESULT IN CIVIL AND
  CRIMINAL ACTION AGAINST YOU.  CONTACT DATALIGHT, INC. AT THE ADDRESS
  SET FORTH ABOVE IF YOU OBTAINED THIS SOFTWARE IN ERROR.
---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
                                Description

    This module contains general functions for manipulating log files and
    log data.
---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
                                Revision History
    $Log: dllogrequestor.c $
    Revision 1.4  2010/11/01 03:24:23Z  garyp
    Modified DclLogOpen() to take a flags parameter rather than a whole
    bunch of bools.  Updated to support binary logs.  Renamed DclLogWrite()
    to DclLogWriteString() to avoid confusion with the new logging capability
    of handling binary logs.
    Revision 1.3  2010/05/19 16:46:16Z  garyp
    Modified so that for private logs, if the fShadow option is used, the
    output will be shadowed using the standard output function (previously
    the combination was disallowed).
    Revision 1.2  2009/11/08 16:50:52Z  garyp
    Minor logic update -- not functionally changed.
    Revision 1.1  2009/06/22 17:14:18Z  garyp
    Initial revision
---------------------------------------------------------------------------*/

#include <dcl.h>

#if DCLCONF_OUTPUT_ENABLED

#include <dllog.h>
#include <dlservice.h>
#include <dlprintf.h>


/*-------------------------------------------------------------------
    Public: DclLogOpen()

    Open a log for capturing output.

    This function's primary purpose is to queue output in a memory
    buffer, and flush it to disk when it becomes full.  If the memory
    buffer is large enough, the output will only be written to disk
    when the log is closed, or when an explicit call to DclLogFlush()
    is made.

    *Special Case*

    If pszFile is NULL and nBufferKB is non-zero, the output will be
    queued in the buffer, and when DclLogClose() is called, it will 
    be dumped to the original output device.  DCLLOGFLAGS_SHADOW 
    would typically always be FALSE in this instance.

    If both pszFile and nBufferKB are NULL and 0 respectively,
    logging will be disabled.  In this case, a handle will still
    be returned, which must be subsequently released with a call
    to DclLogClose() at the time in which logging is to be
    restored to its original state.

    *Public and Private Log Instances*

    Normally the LOG Service hooks into the standard output stream
    so that all output generated by whatever source is handled by 
    the logging system.  This requires that nested nested calls 
    to DclLogOpen() should be matched with corollary calls to 
    DclLogClose() in reverse order.

    However, using the DCLLOGFLAGS_PRIVATE flag causes the log
    to be private and isolated from the standard output stream.
    In this mode, the only way to write to the log is to use
    DclLogWrite(), DclLogWriteString(), DclLogPrintf(), or 
    DclLogVPrintf().

    *Note*

    The log system uses the standard file I/O abstraction in DCL.
    If the output file is on the <same> device for which data is
    being logged, measures must be taken to prevent deadlocks. 
    While the log system itself has protections against being 
    re-entered, if the target FS to which the data is being logged
    is single-threaded and blocks, a deadlock will result when the
    log system writes its data out.

    *Some ways to avoid this*
      1. Log to a different device.
      2. Use a multithreaded FS.
      3. Log using a release version of the FS/device driver which
         will not generate debug output while the FS mutex is held.
      4. Use a memory buffer large enough to contain all the "unsafe"
         intermediate output which will be generated, until such time
         as it can be safely written to disk.

    Parameters:
        hDclInst  - The DCL instance handle.  May be NULL to use the
                    default DCL instance.
        pszFile   - A pointer to the null terminated filename.  If this
                    value is NULL, output will be queued in the buffer
                    (so long as nBufferKB is non-zero).
        nBufferKB - The buffer size in KB.  This value may be zero only
                    in the event that pszFile is NULL, in which case, 
                    logging is disabled.
        ulFlags   - The open flags to use.  May be a combination of the
                    following values:
          DCLLOGFLAGS_APPEND - Indicates that an existing file should
                    be appended to, rather than deleted.
          DCLLOGFLAGS_SHADOW - Indicates that output should be shadowed  
                    to the original output device.  If this flag is used 
                    with a private log, the output will be shadowed using 
                    the high level output functions.
          DCLLOGFLAGS_PRIVATE - Indicates that this log instance should
                    be private in that it is NOT hooked into the standard
                    output chain managed by the DclOutputFunction() logic.
                    If this option is used, the only way to write to the 
                    log is with DclLogPrintf(). 
          DCLLOGFLAGS_BINARY - Indicates that the log output is binary and
                    should be written exactly as received.  Binary logs
                    should be DCLLOGFLAGS_PRIVATE as well, and should not
                    be used with DCLLOGFLAGS_SHADOW.

    Return Value:
        Returns a DCLLOGHANDLE if successful, otherwise NULL.
-------------------------------------------------------------------*/
DCLLOGHANDLE DclLogOpen(
    DCLINSTANCEHANDLE       hDclInst,
    const char             *pszFile,
    unsigned                nBufferKB,
    D_UINT32                ulFlags)
{
    DCLDECLAREREQUESTPACKET (LOG, OPEN, open);  /* DCLREQ_LOG_OPEN */
    DCLSTATUS               dclStat;

    open.pszFile    = pszFile;
    open.nBufferKB  = nBufferKB;
    open.ulFlags    = ulFlags;
    dclStat = DclServiceIoctl(hDclInst, DCLSERVICE_LOG, &open.ior);
    if(dclStat != DCLSTAT_SUCCESS)
    {
        if(dclStat != DCLSTAT_SERVICE_NOTREGISTERED)
        {
            DCLPRINTF(1, ("DclLogOpen() unexpected error %lX\n", dclStat));
        }

        return NULL;
    }

    return open.hLog;
}


/*-------------------------------------------------------------------
    Public: DclLogWrite()

    Write data bytes to a log.  This function may be used to write
    binary data if so desired, however if this is done, it should
    only be used for non-shadowed, private logs.

    Parameters:
        hDclInst - The DCL instance handle.  May be NULL to use
                   the default DCL instance.
        hLog     - A log handle returned by DclLogOpen().
        pData    - A pointer to the data.
        nDataLen - The data length.

    Return Value:
        Returns a DCLSTATUS code indicating the results.
-------------------------------------------------------------------*/
DCLSTATUS DclLogWrite(
    DCLINSTANCEHANDLE       hDclInst,
    DCLLOGHANDLE            hLog,
    const D_BUFFER         *pData,
    size_t                  nDataLen)
{
    DCLDECLAREREQUESTPACKET (LOG, WRITE, write);  /* DCLREQ_LOG_WRITE */
    DCLSTATUS               dclStat;

    if(!hLog)
    {
        DclError();
        return DCLSTAT_LOG_BADHANDLE;
    }

    write.hLog = hLog;
    write.pData = pData;
    write.nDataLen = nDataLen;
    dclStat = DclServiceIoctl(hDclInst, DCLSERVICE_LOG, &write.ior);
    if(dclStat != DCLSTAT_SUCCESS)
    {
        if(dclStat != DCLSTAT_SERVICE_NOTREGISTERED)
        {
            DCLPRINTF(1, ("DclLogWrite() unexpected error %lX\n", dclStat));
        }
    }
    else
    {
        dclStat = write.dclStat;
    }
    
    return dclStat;
}


/*-------------------------------------------------------------------
    Public: DclLogWriteString()

    Write a null-terminated string to the log.

    This function is faster than calling DclLogPrintf() and does not
    (typically) have the maximum line length limitation imposed by
    DCLOUTPUT_BUFFERLEN.

    Parameters:
        hDclInst - The DCL instance handle.  May be NULL to use
                   the default DCL instance.
        hLog     - A log handle returned by DclLogOpen().  If
                   this value is NULL, then the most recently
                   opened NON-private log file will be used.  If
                   there are no open log files, then the output
                   will go to the default output device.
        pszData  - A pointer to the null-terminated format string

    Return Value:
        Returns a DCLSTATUS code indicating the results.
-------------------------------------------------------------------*/
DCLSTATUS DclLogWriteString(
    DCLINSTANCEHANDLE       hDclInst,
    DCLLOGHANDLE            hLog,
    const char             *pszString)
{
    DCLDECLAREREQUESTPACKET (LOG, WRITESTRING, writestring);  /* DCLREQ_LOG_WRITESTRING */
    DCLSTATUS               dclStat;

    writestring.hLog = hLog;
    writestring.pszString = pszString;
    dclStat = DclServiceIoctl(hDclInst, DCLSERVICE_LOG, &writestring.ior);
    if(dclStat != DCLSTAT_SUCCESS)
    {
        if(dclStat != DCLSTAT_SERVICE_NOTREGISTERED)
        {
            DCLPRINTF(1, ("DclLogWriteString() unexpected error %lX\n", dclStat));
        }
    }
    else
    {
        dclStat = writestring.dclStat;
    }
    
    return dclStat;
}


/*-------------------------------------------------------------------
    Public: DclLogFlush()

    Flush a log which was opened with DclLogOpen().

    Note that if the specified log handle is NULL, the "current"
    log instance will be used, however this only applies to
    non-private log instances which are hooked into the standard
    output stream.  Flushing a private log requires that the
    log handle be specified.

    Parameters:
        hDclInst  - The DCL instance handle.  May be NULL to use
                    the default DCL instance.
        hLog      - A log handle returned by DclLogOpen().  If
                    this value is NULL, then the most recently
                    opened NON-private log file will be flushed.

    Return Value:
        Returns a DCLSTATUS code indicating the results.
-------------------------------------------------------------------*/
DCLSTATUS DclLogFlush(
    DCLINSTANCEHANDLE       hDclInst,
    DCLLOGHANDLE            hLog)
{
    DCLDECLAREREQUESTPACKET (LOG, FLUSH, flush);  /* DCLREQ_LOG_FLUSH */
    DCLSTATUS               dclStat;

    flush.hLog = hLog;
    dclStat = DclServiceIoctl(hDclInst, DCLSERVICE_LOG, &flush.ior);
    if(dclStat != DCLSTAT_SUCCESS)
    {
        if(dclStat != DCLSTAT_SERVICE_NOTREGISTERED)
        {
            DCLPRINTF(1, ("DclLogFlush() unexpected error %lX\n", dclStat));
        }
    }
    else
    {
        dclStat = flush.dclStat;
    }
    
    return dclStat;
}


/*-------------------------------------------------------------------
    Public: DclLogClose()

    Close a log file which was opened with DclLogOpen().

    Note that nested calls to DclLogOpen() should be matched
    with corollary calls to DclLogClose() in reverse order.

    Note that if the specified log handle is NULL, the "current"
    log instance will be used, however this only applies to
    non-private log instances which are hooked into the standard
    output stream.  Closing a private log requires that the
    log handle be specified.

    Parameters:
        hDclInst  - The DCL instance handle.  May be NULL to use
                    the default DCL instance.
        hLog      - A log handle returned by DclLogOpen().

    Return Value:
        Returns a DCLSTATUS code indicating the results.
-------------------------------------------------------------------*/
DCLSTATUS DclLogClose(
    DCLINSTANCEHANDLE       hDclInst,
    DCLLOGHANDLE            hLog)
{
    DCLDECLAREREQUESTPACKET (LOG, CLOSE, close);  /* DCLREQ_LOG_CLOSE */
    DCLSTATUS               dclStat;

    if(!hLog)
        return DCLSTAT_LOG_BADHANDLE;

    close.hLog = hLog;
    dclStat = DclServiceIoctl(hDclInst, DCLSERVICE_LOG, &close.ior);
    if(dclStat != DCLSTAT_SUCCESS)
    {
        if(dclStat != DCLSTAT_SERVICE_NOTREGISTERED)
        {
            DCLPRINTF(1, ("DclLogClose() unexpected error %lX\n", dclStat));
        }
    }
    else
    {
        dclStat = close.dclStat;
    }
    
    return dclStat;
}


/*-------------------------------------------------------------------
    Public: DclLogMode()

    Get/set the logging mode.

    Note that if the specified log handle is NULL, the "current" log
    instance will be used, however this only applies to non-private
    log instances which are hooked into the standard output stream.
    Manipulating the mode flags for private logs requires that the
    log handle be specified.

    Parameters:
        hDclInst  - The DCL instance handle.  May be NULL to use
                    the default DCL instance.
        hLog      - A log handle returned by DclLogOpen().
        nMode     - One or more of the DCLLOGMODE_* values.

    Return Value:
        Returns a DCLSTATUS code indicating the results.
-------------------------------------------------------------------*/
DCLLOGMODE DclLogMode(
    DCLINSTANCEHANDLE       hDclInst,
    DCLLOGHANDLE            hLog,
    DCLLOGMODE              nMode)
{
    DCLDECLAREREQUESTPACKET (LOG, MODE, mode);  /* DCLREQ_LOG_MODE */
    DCLSTATUS               dclStat;

    DclAssert(nMode > DCLLOGMODE_LOWLIMIT && nMode < DCLLOGMODE_HIGHLIMIT);

    mode.hLog = hLog;
    mode.nMode = nMode;
    dclStat = DclServiceIoctl(hDclInst, DCLSERVICE_LOG, &mode.ior);
    if(dclStat != DCLSTAT_SUCCESS)
    {
        if(dclStat != DCLSTAT_SERVICE_NOTREGISTERED)
        {
            DCLPRINTF(1, ("DclLogMode() unexpected error %lX\n", dclStat));
        }

        return DCLLOGMODE_FAILED;
    }

    return mode.nOldMode;
}


/*-------------------------------------------------------------------
    Public: DclLogVPrintf()

    Print formatted data with a pointer to an argument list to
    the specified log instance.

    This function provides a subset of the ANSI C vprintf()
    functionality with several extensions to support fixed
    size data types.

    See DclVSNPrintf() for the list of supported types.

    This function accommodates a maximum output length of
    DCLOUTPUT_BUFFERLEN.  If this function must truncate the
    output, and the original string was \n terminated, the
    truncated output will be \n terminated as well.

    *Note* -- This function is typically only used when a private
              log is in use, since non-private logs are hooked into
              the standard output hierarchy, and therefore the
              regular DclVPrintf() function can be used.

    Parameters:
        hDclInst - The DCL instance handle.  May be NULL to use
                   the default DCL instance.
        hLog     - A log handle returned by DclLogOpen().  If
                   this value is NULL, then the most recently
                   opened NON-private log file will be used.  If
                   there are no open log files, then the output
                   will go to the default output device.
        pszFmt   - A pointer to the null-terminated format string
        arglist  - The variable length argument list

    Return Value:
        Returns the length output.
-------------------------------------------------------------------*/
int DclLogVPrintf(
    DCLINSTANCEHANDLE   hDclInst,
    DCLLOGHANDLE        hLog,
    const char         *pszFmt,
    va_list             arglist)
{
    int                 iLen;
    char                achBuffer[DCLOUTPUT_BUFFERLEN];

    if(!pszFmt)
        return 0;

    iLen = DclVSNPrintf(achBuffer, sizeof(achBuffer), pszFmt, arglist);

    DclAssert(iLen < DCLOUTPUT_BUFFERLEN);

    if(iLen < 0)
    {
        /*  DclVSNPrintf() will return -1 if we ran out of buffer space.
            If this happens truncate the data.
        */

        /*  Return the full buffer length, minus the null-terminator
        */
        iLen = sizeof(achBuffer) - 1;

        /*  Ensure we are null terminated.
        */
        achBuffer[iLen] = 0;

        /*  If the original string was \n terminated and the new one is
            not, due to truncation, stuff a \n into the new one.
        */
        if(pszFmt[DclStrLen(pszFmt)-1] == '\n')
            achBuffer[iLen-1] = '\n';
    }

    if(DclLogWriteString(hDclInst, hLog, achBuffer) != DCLSTAT_SUCCESS)
        iLen = 0;

    return iLen;
}


/*-------------------------------------------------------------------
    Public: DclLogPrintf()

    Print formatted data with a variable argument list to a
    log instance.

    This function provides a subset of the ANSI C printf()
    functionality with several extensions to support fixed
    size data types.

    See DclVSNPrintf() for the list of supported types.

    *Note* -- This function is typically only used when a private
              log is in use, since non-private logs are hooked into
              the standard output hierarchy, and therefore the
              regular DclPrintf() function can be used.

    Parameters:
        hDclInst - The DCL instance handle.  May be NULL to use
                   the default DCL instance.
        hLog     - A log handle returned by DclLogOpen().  If
                   this value is NULL, then the most recently
                   opened NON-private log file will be used.  If
                   there are no open log files, then the output
                   will go to the default output device.
        pszFmt   - A pointer to the null-terminated format string
        ...      - The variable length argument list

    Return Value:
        Returns the length processed.
-------------------------------------------------------------------*/
int DclLogPrintf(
    DCLINSTANCEHANDLE   hDclInst,
    DCLLOGHANDLE        hLog,
    const char         *pszFmt,
    ...)
{
    int                 nLen;
    va_list             arglist;

    if(!pszFmt)
        return 0;

    va_start(arglist, pszFmt);

    nLen = DclLogVPrintf(hDclInst, hLog, pszFmt, arglist);

    va_end(arglist);

    return nLen;
}




#endif  /* DCLCONF_OUTPUT_ENABLED */

