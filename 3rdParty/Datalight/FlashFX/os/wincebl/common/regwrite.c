/*---------------------------------------------------------------------------
               ----> DO NOT REMOVE THE FOLLOWING NOTICE <----

                  Copyright (c) 1993 - 2008 Datalight, Inc.
                       All Rights Reserved Worldwide.

  Datalight, Incorporated is a Washington State corporation located at:

        21520 30th Dr SE, Suite 110,      Tel:  425-951-8086
        Bothell, WA  98021                Fax:  425-951-8094
        USA                               Web:  http://www.datalight.com

  This software, including without limitation all source code and documen-
  tation, is the confidential, trade secret property of Datalight, Inc.
  and is protected under the copyright laws of the United States and other
  jurisdictions.  The software may be subject to one or more of these US
  patents: US#5860082, US#6260156.  Patents may be pending.

  In addition to civil penalties for infringement of copyright under appli-
  cable U.S. law, 17 U.S.C. 1204 provides criminal penalties for violation
  of (a) the restrictions on circumvention of copyright protection systems
  found in 17 U.S.C. 1201 and (b) the protections for the integrity of
  copyright management information found in 17 U.S.C. 1202.

  U.S. Government Restricted Rights:  Use, duplication, reproduction, or
  transfer of this commercial product and accompanying documentation is
  restricted in accordance with FAR 12.212 and DFARS 227.7202 and by a
  License Agreement.

  IN ADDITION TO COPYRIGHT AND PATENT LAW, THIS SOFTWARE IS PROTECTED UNDER
  A SOURCE CODE AGREEMENT, NON-DISCLOSURE AGREEMENT, AND/OR SIMILAR BINDING
  CONTRACT BETWEEN DATALIGHT, INC. AND THE LICENSEE ("BINDING AGREEMENTS").
  IF YOU ARE A LICENSEE, YOUR RIGHT, IF ANY, TO COPY, PUBLISH, MODIFY, OR
  OTHERWISE USE THE SOFTWARE, IS SUBJECT TO THE TERMS AND CONDITIONS OF THE
  BINDING AGREEMENTS.  BY USING THE SOFTWARE IN ANY MANNER, IN WHOLE OR IN
  PART, YOU AGREE TO BE BOUND BY THE TERMS OF THE BINDING AGREEMENTS.

  IF YOU ARE NOT A DATALIGHT LICENSEE, ANY USE MAY RESULT IN CIVIL AND
  CRIMINAL ACTION AGAINST YOU.  CONTACT DATALIGHT, INC. AT THE ADDRESS
  SET FORTH ABOVE IF YOU OBTAINED THIS SOFTWARE IN ERROR.
---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
                                Description

    This module implements the FlashFX version of the Windows CE
    WriteRegistryToOEM() function.  This function allows OEMs to save
    the contents of the WinCE registry on a FlashFX disk using the Win32
    file system API.  This persistent copy of the registry may be restored
    using the FXReadRegistryToOEM function.  The name of the registry file
    to read is specified in the REG_PATH_NAME constant in FXREG.H.
---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
                                Revision History
    $Log: regwrite.c $
    Revision 1.4  2008/01/25 07:34:46Z  keithg
    Comment style updates to support autodoc.
    Revision 1.3  2007/11/03 23:50:17Z  Garyp
    Updated to use the standard module header.
    Revision 1.2  2006/01/12 04:49:52Z  Garyp
    Documentation, debug code, and general cleanup -- no functional changes.
    Revision 1.1  2004/12/31 02:43:18Z  Pauli
    Initial revision
    Revision 1.2  2004/12/30 23:43:18Z  GaryP
    Updated to use indents of 4, hard tabs of 8 (if used), and a standard
    comment style.
    Revision 1.1  2004/08/17 18:28:04Z  garyp
    Initial revision
---------------------------------------------------------------------------*/
#include <windows.h>
#include <pwinreg.h>
#include <diskio.h>

#include "fxreg.h"


/*  This is the write buffer.  The default size is 32K but it may be
    decreased at the cost of performance.  The minimum size of the
    buffer is the allocator block size.
*/
#define REG_WRITE_BUFF_SIZE      (0x8000)
unsigned char   rgucDataBuffer[REG_WRITE_BUFF_SIZE];


/*  These are the external declarations for the functions that we need to
    have available in NK.LIB.  The OAL must provide the ability to load
    a DLL, resolve the address of a function contained within that DLL and
    to report the last error code generated by a system call.
*/
extern HINSTANCE __cdecl SC_LoadLibraryW(LPCTSTR lpLibFileName);
extern FARPROC   __cdecl SC_GetProcAddressW(HMODULE hModule, LPCWSTR lpProcName);
extern DWORD     __cdecl SC_GetLastError(void);


/*  These are the implicit declarations for the four functions we rely on
    from COREDLL.DLL to provide the W32 file syatem API used to save the
    registery.  Unfortunatley, we cannot use implicit linkage in the OAL.
    These declarations are provided as a matter of information only.

__declspec(dllimport) BOOL __cdecl SetFileAttributes( LPCTSTR lpFileName,
                                         DWORD dwFileAttributes );
__declspec(dllimport) HANDLE __cdecl CreateFile( LPCTSTR lpFileName,
                                     DWORD dwDesiredAccess,
                                     DWORD dwShareMode,
                                     LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                     DWORD dwCreationDispostion,
                                     DWORD dwFlagsAndAttributes,
                                     HANDLE hTemplateFile );
__declspec(dllimport) BOOL __cdecl WriteFile( HANDLE hFile,
                                    LPCVOID lpBuffer,
                                    DWORD nNumberOfBytesToWrite,
                                    LPDWORD lpNumberOfBytesWritten,
                                    LPOVERLAPPED lpOverlapped );
__declspec(dllimport) BOOL __cdecl CloseHandle( HANDLE hObject );
*/


/*  These are the typedefs for the function pointers we call to invoke
    the W32 file system API functions described above.
*/
typedef         BOOL(
    WINAPI * SET_FILE_ATTRIBUTES_FUNC) (
    LPCTSTR lpFileName,
    DWORD dwFileAttributes);
typedef         HANDLE(
    WINAPI * CREAT_FILE_FUNC) (
    LPCTSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDispostion,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile);
typedef         BOOL(
    WINAPI * WRITE_FILE_FUNC) (
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped);
typedef         BOOL(
    WINAPI * CLOSE_HANDLE_FUNC) (
    HANDLE hObject);


/*  The global variables used to hold the handle to COREDLL.DLL (returned by
    SC_LoadModuleW) and the API entry points of the routines we need to use
    from the DLL (returned by SC_GetProcAddressW).
*/
HINSTANCE       hDll;
SET_FILE_ATTRIBUTES_FUNC pSetFileAttributes;
CREAT_FILE_FUNC pCreateFile;
WRITE_FILE_FUNC pWriteFile;
CLOSE_HANDLE_FUNC pCloseHandle;


/*-------------------------------------------------------------------
    This is a state machine that actually saves the registry entries onto the
    FlashFX disk.  The W32 file system API is used to avoid contention. The
    arguments and return value of this function are exactly the same as
    specified by the WinCE WriteRegitstryToOEM function (see the discussion
    of the FXWriteRegistryToOEM function below.)

    The FXWriteRegistryToOEM function simply relays the calls it receives
    from the file system on to this routine, if it can load COREDLL.DLL and
    resolve the address of all needed funtions within that module.
-------------------------------------------------------------------*/
BOOL __cdecl W32WriteRegistryToOEM(
    DWORD                   dwFlags,
    LPBYTE                  lpData,
    DWORD                   cbData)
{
    static REGSTATEMACHINE  stateMachine = SM_DORMANT;
    static HANDLE           hFile;
    static unsigned int     uFreeBytesInBuffer;
    static DWORD            dwTotalWritten;
    BOOL                    fWriteResult;
    DWORD                   dwBytesLeftToRead;

  NEXT_STATE:
    switch (stateMachine)
    {
        case SM_DORMANT:
            RETAILMSG(1, (TEXT("\r\nW32WriteRegistryToOEM: Initializing.\r\n")));

            if((dwFlags != REG_WRITE_BYTES_START) && (dwFlags != 0))
            {
                RETAILMSG(1, (TEXT("\r\nW32WriteRegistryToOEM: Unknown dwFlags argument: 0x%x\r\n"),
                           dwFlags));

#if D_DEBUG

                /*  Since ASSERT does not work...
                */
                DebugBreak();
#endif

                stateMachine = SM_BROKEN;
                goto NEXT_STATE;
            }

            /*  Force flags off when leaving the dormant state so we can test them
                later on.
            */
            dwFlags = 0;

            stateMachine = SM_OPENING;

            /*  Fall through from successful init to open the file...
            */
        case SM_OPENING:
            DEBUGMSG(0, (TEXT("\r\nW32WriteRegistryToOEM: Opening registry file: %s.\r\n"),
                      (LPCTSTR) (REG_PATH_NAME)));

            pSetFileAttributes((LPCTSTR) (REG_PATH_NAME),
                               FILE_ATTRIBUTE_NORMAL);

            hFile = pCreateFile((LPCTSTR) (REG_PATH_NAME), GENERIC_WRITE,
                                0, NULL, CREATE_ALWAYS,
                                FILE_ATTRIBUTE_HIDDEN |
                                FILE_ATTRIBUTE_READONLY |
                                FILE_ATTRIBUTE_ARCHIVE, 0);

            if(hFile == INVALID_HANDLE_VALUE)
            {
                RETAILMSG(1, (TEXT("\r\nW32WriteRegistryToOEM: Error creating registry file, errorcode = %d\r\n"),
                           SC_GetLastError()));

                stateMachine = SM_BROKEN;
                goto NEXT_STATE;
            }

            stateMachine = SM_ACCESSING;
            uFreeBytesInBuffer = REG_WRITE_BUFF_SIZE;

            dwTotalWritten = 0;

            /*  Fall through from successful open to start writing the file...
            */
        case SM_ACCESSING:
            if(dwFlags != 0)
            {
                RETAILMSG(1, (TEXT("\r\nW32WriteRegistryToOEM: non-zero dwFlags in accessing state: 0x%x\r\n"),
                           dwFlags));

#if D_DEBUG

                /*  Since ASSERT does not work...
                */
                DebugBreak();
#endif

                stateMachine = SM_BROKEN;
                goto NEXT_STATE;
            }

            if(cbData == 0)
            {
                DEBUGMSG(0, (TEXT("\r\nW32WriteRegistryToOEM: Got (cbData=0), closing registry file.\r\n")));

                stateMachine = SM_CLOSING;
                goto NEXT_STATE;
            }
            DEBUGMSG(0, (TEXT("\r\nW32WriteRegistryToOEM: Buffering 0x%x bytes to registry file at offset %08X.\r\n"),
                      cbData, dwTotalWritten));

            dwBytesLeftToRead = cbData;
            while(dwBytesLeftToRead > 0)
            {
                /* Fill up our transfer buffer...
                   We expect many small writes. If large writes are encountered
                   this first conditional clause could be modified to avoid double
                   buffering for large values of cbData.
                */
                if(dwBytesLeftToRead > uFreeBytesInBuffer)
                {
                    memmove(&rgucDataBuffer
                            [REG_WRITE_BUFF_SIZE - uFreeBytesInBuffer],
                            lpData, uFreeBytesInBuffer);
                    lpData += uFreeBytesInBuffer;
                    dwBytesLeftToRead -= uFreeBytesInBuffer;
                    uFreeBytesInBuffer = 0;
                }
                else
                {
                    memmove(&rgucDataBuffer
                            [REG_WRITE_BUFF_SIZE - uFreeBytesInBuffer],
                            lpData, dwBytesLeftToRead);
                    uFreeBytesInBuffer -= dwBytesLeftToRead;
                    dwBytesLeftToRead = 0;
                }

                /*  If our transfer buffer is full, then flush it...
                */
                if(uFreeBytesInBuffer == 0)
                {
                    DWORD           dwBytesWritten;
                    DEBUGMSG(0, (TEXT("\r\nW32WriteRegistryToOEM: Flushing buffer to registry file.\r\n")));

                    fWriteResult =
                        pWriteFile(hFile, rgucDataBuffer, REG_WRITE_BUFF_SIZE,
                                   &dwBytesWritten, NULL);
                    if(!fWriteResult)
                    {
                        RETAILMSG(1, (TEXT("W32WriteRegistryToOEM: Error writing to file, errorcode = %d\r\n"),
                                   SC_GetLastError()));

                        stateMachine = SM_BROKEN;
                        goto NEXT_STATE;
                    }
                    DEBUGMSG(0, (TEXT("W32WriteRegistryToOEM: Wrote %d bytes to FlashFX registry file %s\r\n"),
                              dwBytesWritten, (LPCTSTR) (REG_PATH_NAME)));

                    uFreeBytesInBuffer = REG_WRITE_BUFF_SIZE;
                }
            }

            dwTotalWritten += cbData;

            break;

            /*  The registry data was successfully saved on the FlashFX disk.
            */
        case SM_CLOSING:
            if((REG_WRITE_BUFF_SIZE - uFreeBytesInBuffer) > 0)
            {
                DWORD           dwBytesWritten;

                DEBUGMSG(0, (TEXT("\r\nW32WriteRegistryToOEM: Flushing buffer to registry file.\r\n")));

                fWriteResult =
                    pWriteFile(hFile, rgucDataBuffer,
                               (REG_WRITE_BUFF_SIZE - uFreeBytesInBuffer),
                               &dwBytesWritten, NULL);
                if(!fWriteResult)
                {
                    RETAILMSG(1, (TEXT("W32WriteRegistryToOEM: Error writing to file, errorcode = %d\r\n"),
                               SC_GetLastError()));

                    stateMachine = SM_BROKEN;
                    goto NEXT_STATE;
                }
                DEBUGMSG(0, (TEXT("W32WriteRegistryToOEM: Wrote %d bytes to FlashFX registry file %s\r\n"),
                          dwBytesWritten, (LPCTSTR) (REG_PATH_NAME)));
            }

            RETAILMSG(1, (TEXT("\r\nW32WriteRegistryToOEM: Registry file '%s' saved on FlashFX disk (%d bytes).\r\n"),
                       (LPCTSTR) (REG_PATH_NAME), dwTotalWritten));

            pCloseHandle(hFile);
            stateMachine = SM_DORMANT;
            break;

            /*  Something is dreadfully wrong...
            */
        case SM_BROKEN:
        default:
            RETAILMSG(1, (TEXT("\r\nW32WriteRegistryToOEM: Registry write machine is broken.\r\n")));

            pCloseHandle(hFile);
            break;
    }

    /*  Always return TRUE, even if we are broken, so as to avoid confusing
        WriteRegistry
    */
    return TRUE;
}


/*-------------------------------------------------------------------
    Public: FXWriteRegistryToOem

   Write the registry to a FlashFX disk.
   This routine is the FlashFX version of the Windows CE
   WriteRegistryToOEM() function.  The arguments and return
   value are as documented by Microsoft.  It is the OEM's
   responsibility assign the address of this function to the
   global pWriteRegistryToOEM.(during OEMInit, for example.)

   This function simply attempts to load CORRDLL.DLL and resolve
   the addresses of the functions described above.  The mechanisms
   to do so must be supplied by the OEM.  Once all the addresses
   of all the needed W32 file system API functions are determined,
   the file system calls to save the registry are simple passed on
   to W32WriteRegistryToOEM() above.

   The path name of the file created by this module is defined in
   FXREGS.H as REG_PATH_NAME.

    Parameters:
       dwFlags
          Write options specified by the file system.  The only
          supported flag is REG_WRITE_BYTES_START, This causes
          the registry file to be over-written with the current
          registry data..All other non-zero values cause this
          routine to fail.
       lpData
          A pointer to the buffer allocated by the OS containing
          the data to be written out to the registry file.
       cbData
          The number of bytes to write to file from the buffer. A zero
          value indicates that all the registry data has been saved.

    Return:
       TRUE on success else FALSE.
-------------------------------------------------------------------*/
BOOL FXWriteRegistryToOEM(
    DWORD           dwFlags,
    LPBYTE          lpData,
    DWORD           cbData)
{
    BOOL            fResult = FALSE;
    static BOOL     fNeedingCoreDLL = TRUE;

    /*  The first time we are called we need to load COREDLL.DLL
    */
    while(fNeedingCoreDLL)
    {
        hDll = SC_LoadLibraryW((const unsigned short *)_T("COREDLL.DLL"));
        if(hDll == NULL)
        {
            RETAILMSG(1, (TEXT("\r\nFXWriteRegistryToOEM: Could not load COREDLL.DLL, aborting.\r\n")));
            RETAILMSG(1, (TEXT("\r\nFXWriteRegistryToOEM: GetLastError Returned 0x%X.\r\n"),
                       SC_GetLastError()));
            break;
        }
        pSetFileAttributes =
            (SET_FILE_ATTRIBUTES_FUNC) SC_GetProcAddressW(hDll,
                                                          (const unsigned
                                                           short *)
                                                          _T
                                                          ("SetFileAttributesW"));
        if(pSetFileAttributes == NULL)
        {
            RETAILMSG(1, (TEXT("\r\nFXWriteRegistryToOEM: Could not resolve SetFileAttributes, aborting.\r\n")));
            RETAILMSG(1, (TEXT("\r\nFXWriteRegistryToOEM: GetLastError Returned 0x%X.\r\n"),
                       SC_GetLastError()));
            break;
        }
        pCreateFile =
            (CREAT_FILE_FUNC) SC_GetProcAddressW(hDll,
                                                 (const unsigned short *)
                                                 _T("CreateFileW"));
        if(pCreateFile == NULL)
        {
            RETAILMSG(1, (TEXT("\r\nFXWriteRegistryToOEM: Could not resolve CreateFile, aborting.\r\n")));
            RETAILMSG(1, (TEXT("\r\nFXWriteRegistryToOEM: GetLastError Returned 0x%X.\r\n"),
                       SC_GetLastError()));
            break;
        }
        pWriteFile = (WRITE_FILE_FUNC) SC_GetProcAddressW(hDll,
                                                 (const unsigned short *)
                                                 _T("WriteFile"));
        if(pWriteFile == NULL)
        {
            RETAILMSG(1, (TEXT("\r\nFXWriteRegistryToOEM: Could not resolve WriteFile, aborting.\r\n")));
            RETAILMSG(1, (TEXT("\r\nFXWriteRegistryToOEM: GetLastError Returned 0x%X.\r\n"),
                       SC_GetLastError()));
            break;
        }
        pCloseHandle = (CLOSE_HANDLE_FUNC) SC_GetProcAddressW(hDll,
                                                   (const unsigned short *)
                                                   _T("CloseHandle"));
        if(pCloseHandle == NULL)
        {
            RETAILMSG(1, (TEXT("\r\nFXWriteRegistryToOEM: Could not resolve CloseHandle, aborting.\r\n")));
            RETAILMSG(1, (TEXT("\r\nFXWriteRegistryToOEM: GetLastError Returned 0x%X.\r\n"),
                       SC_GetLastError()));
            break;
        }
        fNeedingCoreDLL = FALSE;
    }

    /*  Once COREDLL is successfully loaded we just pass on all the calls
        to the W32 file system routine above.
    */
    if(!fNeedingCoreDLL)
        fResult = W32WriteRegistryToOEM(dwFlags, lpData, cbData);

    return fResult;
}
