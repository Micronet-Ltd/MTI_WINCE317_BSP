/*---------------------------------------------------------------------------
               ----> DO NOT REMOVE THE FOLLOWING NOTICE <----

                  Copyright (c) 1993 - 2007 Datalight, Inc.
                       All Rights Reserved Worldwide.

  Datalight, Incorporated is a Washington State corporation located at:

        21520 30th Dr SE, Suite 110,      Tel:  425-951-8086
        Bothell, WA  98021                Fax:  425-951-8094
        USA                               Web:  http://www.datalight.com

  This software, including without limitation all source code and documen-
  tation, is the confidential, trade secret property of Datalight, Inc.
  and is protected under the copyright laws of the United States and other
  jurisdictions.  The software may be subject to one or more of these US
  patents: US#5860082, US#6260156.  Patents may be pending.

  In addition to civil penalties for infringement of copyright under appli-
  cable U.S. law, 17 U.S.C. 1204 provides criminal penalties for violation
  of (a) the restrictions on circumvention of copyright protection systems
  found in 17 U.S.C. 1201 and (b) the protections for the integrity of
  copyright management information found in 17 U.S.C. 1202.

  U.S. Government Restricted Rights:  Use, duplication, reproduction, or
  transfer of this commercial product and accompanying documentation is
  restricted in accordance with FAR 12.212 and DFARS 227.7202 and by a
  License Agreement.

  IN ADDITION TO COPYRIGHT AND PATENT LAW, THIS SOFTWARE IS PROTECTED UNDER
  A SOURCE CODE AGREEMENT, NON-DISCLOSURE AGREEMENT, AND/OR SIMILAR BINDING
  CONTRACT BETWEEN DATALIGHT, INC. AND THE LICENSEE ("BINDING AGREEMENTS").
  IF YOU ARE A LICENSEE, YOUR RIGHT, IF ANY, TO COPY, PUBLISH, MODIFY, OR
  OTHERWISE USE THE SOFTWARE, IS SUBJECT TO THE TERMS AND CONDITIONS OF THE
  BINDING AGREEMENTS.  BY USING THE SOFTWARE IN ANY MANNER, IN WHOLE OR IN
  PART, YOU AGREE TO BE BOUND BY THE TERMS OF THE BINDING AGREEMENTS.

  IF YOU ARE NOT A DATALIGHT LICENSEE, ANY USE MAY RESULT IN CIVIL AND
  CRIMINAL ACTION AGAINST YOU.  CONTACT DATALIGHT, INC. AT THE ADDRESS
  SET FORTH ABOVE IF YOU OBTAINED THIS SOFTWARE IN ERROR.
---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
                                Description

    This module contains the FIM code for Intel "FlashFile" flash which is
    organized in an 16-bit wide, non-interleaved fashion.
---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
                                Revision History
    $Log: iffx16.c $
    Revision 1.11  2007/11/03 23:49:37Z  Garyp
    Updated to use the standard module header.
    Revision 1.10  2006/11/21 21:23:24Z  rickc
    Fixed high boot block support
    Revision 1.9  2006/10/07 01:56:39Z  Garyp
    Corrected to eliminate warnings generated by the RealView tools.
    Revision 1.8  2006/08/29 17:23:06Z  pauli
    Updated to use the new FfxFimNorWindowCreate/FfxFimNorWindowMap
    functions.
    Revision 1.7  2006/06/07 01:55:03Z  Pauli
    Updated boot block handling to work with non boot block parts.
    Revision 1.6  2006/05/21 18:28:30Z  Garyp
    Modified to use a more flexible mechanism for handling boot blocks, which
    is compatible with NORWRAP FIM.
    Revision 1.5  2006/05/12 00:44:42Z  Pauli
    Corrected an assignment in an assert statement that should be an equality
    check.
    Revision 1.4  2006/05/11 21:18:10Z  tonyq
    Modify flash erase logic to properly support bootblock parts, and add those
    parts to supported parts table.
    Revision 1.3  2006/02/10 21:08:04Z  Garyp
    Renamed the FIMDEVICE structure instantiation for clarity.
    Revision 1.2  2006/02/08 18:36:08Z  Garyp
    Modified to use new FfxHookWindowMap/Size() functions.  Updated debugging
    code.
    Revision 1.1  2005/10/14 02:08:00Z  Pauli
    Initial revision
    Revision 1.9  2005/05/16 19:54:43Z  garyp
    Removed some bogus asserts.  The media pointer can legally be zero on some
    platforms.
    Revision 1.8  2005/05/13 02:36:03Z  garyp
    Commented out support for parts that appear bogus for this FIM.
    Revision 1.7  2005/05/09 19:05:32Z  garyp
    Updated to use ID_ENDOFLIST.
    Revision 1.6  2005/05/08 17:07:20Z  garyp
    Major refactoring of the FIM commands so that all Intel based FIMs use
    the same logic.  Few algorithmic changes exceot the flash ID process, and
    a minor tweak to the flash search loop to start with the second chip.
    Revision 1.5  2004/12/30 23:17:56Z  GaryP
    Updated to use indents of 4, hard tabs of 8 (if used), and a standard
    comment style.
    Revision 1.4  2004/08/05 16:34:08Z  billr
    Move optional functions to the end of FIMDEVICE.
    Revision 1.3  2004/08/04 21:56:31Z  billr
    Eliminate ulInterleaved in ExtndMediaInfo, no longer used or needed.
    Revision 1.2  2004/08/04 21:25:08Z  billr
    Eliminate ulFimFlags in ExtndMediaInfo, no longer used or needed.
    Revision 1.1  2004/07/22 21:45:48Z  jaredw
    Initial revision
---------------------------------------------------------------------------*/

#include <flashfx.h>
#include <fimdev.h>
#include "nor.h"

/*  Configure for a 1x16 layout
*/
#define FLASH_INTERLEAVE    1       /* Number of flash chips interleaved    */
#define FLASH_BUS_WIDTH     16      /* Overall data bus width in bits       */

#include "flashcmd.h"
#include "intelcmd.h"

/*  ulEraseResult value; used internally to clarify intent.
*/
#define ERASE_IN_PROGRESS       (0)

/*  The minimum amount of time (in microseconds) to let a suspended
    erase progress to ensure that some forward progress is made.
*/
#define MINIMUM_ERASE_INCREMENT (1000)

/*  data sheet says max is 10 seconds typical ~.5 sec
*/
#define ERASE_TIMEOUT           (15 * 1000L)

/*  mili sec, spec says max ~25 usec
*/
#define ERASE_SUSPEND_TIMEOUT   (1)

/*  max of 300 micro sec
*/
#define WRITE_TIMEOUT           (1)

/*  Internal prototypes
*/
static void ResetFlash(PFLASHDATA pMedia);

/*  All parts supported in this FIM have 64KB erase zones --
    multiply appropriately for the interleave value.
*/
#define ZONE_SIZE               (0x00010000UL * FLASH_INTERLEAVE) /* 64KB */
#define BOOT_ZONE_SIZE          (0x00002000UL * FLASH_INTERLEAVE) /* 8KB */

typedef struct tagFIMEXTRA
{
    int         iSuspend;
    DCLTIMER    tErase;
    D_UINT32    ulEraseStart;
    D_UINT32    ulEraseResult;
    D_UINT32    ulTimeoutRemaining;
    PFLASHDATA  pMedia;
    D_UINT16    uHighBootBlockStart;
    unsigned    fInBootBlocks : 1;
} FIMEXTRA;

static INTELCHIPPARAMS ChipTable[] =
{
/*  {ID_INTEL66A0},     Where is the data sheet for this part */
    {ID_28F800C3T},
    {ID_28F800C3B},
    {ID_28F160C3T},
    {ID_28F160C3B},
    {ID_28F320C3T},
    {ID_28F320C3B},
    {ID_28F640C3T},
    {ID_28F640C3B},
    {ID_28F160S3 },
    {ID_28F320S3 },
    {ID_ENDOFLIST}
};


/*-------------------------------------------------------------------
    Mount()

    Description
        Determines if the media is indeed supported.  If so the
        ExtndMediaInfo structure is updated to reflect it.

    Parameters
        pEMI - A pointer to the ExtndMediaInfo structure to use.

    Return Value
        Returns TRUE if successful, else FALSE
-------------------------------------------------------------------*/
static D_BOOL Mount(
    PEXTMEDIAINFO   pEMI)
{
    D_UINT32        ulAddress = 0L;
    unsigned        i;
    PFLASHDATA      pMedia;
    FLASHIDCODES    ID;
    FFXFIMBOUNDS    bounds;

    DclAssert(pEMI);

    pEMI->uDeviceType       = DEV_NOR | DEV_NOT_MLC;
    pEMI->ulEraseZoneSize   = ZONE_SIZE;

    /*  Get the array bounds and map the window.
    */
    FfxDevGetArrayBounds(pEMI->hDev, &bounds);
    if(!FfxFimNorWindowCreate(pEMI->hDev, ulAddress, &bounds, (volatile void **)&pMedia))
        return FALSE;

    /*  ID first chip
    */
    ResetFlash(pMedia);
    *pMedia = INTLCMD_IDENTIFY;
    GETFLASHIDCODES(&ID, pMedia);
    if(!ISVALIDFLASHIDCODE(&ID))
    {
        FFXPRINTF(1, ("FIM iffx16:   Invalid flash ID: Data0/1=%04x/%04x\n",
            ID.data0, ID.data1));

        ResetFlash(pMedia);

        return FALSE;
    }

    /*  search the device codes list for the detected ID code
    */
    for(i = 0; ChipTable[i].ulChipSize != D_UINT32_MAX; i++)
    {
        if((ID.idMfg == ChipTable[i].idMfg) &&
           (ID.idDev == ChipTable[i].idDev))
        {
            pEMI->ulDeviceSize = ChipTable[i].ulChipSize * FLASH_INTERLEAVE;

            FFXPRINTF(1, ("FIM iffx16:   Mfg/Dev=%04x/%04x supported\n", ID.idMfg, ID.idDev));

            break;
        }
    }

    if(ChipTable[i].ulChipSize == D_UINT32_MAX)
    {
        FFXPRINTF(1, ("FIM iffx16:   Mfg/Dev=%04x/%04x unsupported\n", ID.idMfg, ID.idDev));

        /*  Otherwise, device not found, so restore the original state
            and return device not found.
        */
        ResetFlash(pMedia);

        return FALSE;
    }

    /*  Search for additional devices in a linear array.  Leave the first
        chips in Identify mode to detect wrap around (aliasing).  Since we've
        already identified the first devices, start at the next offset.
    */
    for(ulAddress = pEMI->ulDeviceSize;
        ulAddress < MAX_ARRAY;
        ulAddress += pEMI->ulDeviceSize)
    {
        FLASHIDCODES    ID2;

        if(!FfxFimNorWindowCreate(pEMI->hDev, ulAddress, &bounds, (volatile void **)&pMedia))
            break;

        /*  Check for wrap around
        */
        GETFLASHIDCODES(&ID2, pMedia);
        if((ID2.data0 == ID.data0) && (ID2.data1 == ID.data1))
            break;

        /*  ID each chip
        */
        ResetFlash(pMedia);
        *pMedia = INTLCMD_IDENTIFY;
        GETFLASHIDCODES(&ID2, pMedia);
        if((ID2.data0 != ID.data0) || (ID2.data1 != ID.data1))
            break;

        /*  Reset the flash to read mode.  The first device in the array is
            not included in this loop, so we don't need any special cases.
        */
        ResetFlash(pMedia);
    }

    /*  Restore the first chip to read mode
    */
    if(!FfxFimNorWindowCreate(pEMI->hDev, 0L, &bounds, (volatile void **)&pMedia))
        return FALSE;

    ResetFlash(pMedia);

    pEMI->ulTotalSize = ulAddress;

    pEMI->pFimExtra = DclMemAllocZero(sizeof *pEMI->pFimExtra);
    if(!pEMI->pFimExtra)
        return FALSE;

    if(ChipTable[i].uLowBootBlocks || ChipTable[i].uHighBootBlocks)
    {
        pEMI->ulBootBlockSize = BOOT_ZONE_SIZE;

        pEMI->uBootBlockCountLow = (D_UINT16)
            (ZONE_SIZE / BOOT_ZONE_SIZE * ChipTable[i].uLowBootBlocks);

        pEMI->uBootBlockCountHigh = (D_UINT16)
            (ZONE_SIZE / BOOT_ZONE_SIZE * ChipTable[i].uHighBootBlocks);

        if(pEMI->uBootBlockCountHigh)
        {
            /*  If we have high boot blocks, calculate a boot block number,
                relative to the chip size, above which we will be erasing
                boot blocks rather than regular blocks.
            */
            pEMI->pFimExtra->uHighBootBlockStart = (D_UINT16)
                ((pEMI->ulDeviceSize / pEMI->ulBootBlockSize) - pEMI->uBootBlockCountHigh);

            DclAssert(pEMI->pFimExtra->uHighBootBlockStart != D_UINT16_MAX);
        }

        FFXPRINTF(1, ("FIM iffx16: BootBlockSize=%lUKB Low=%U High=%U\n",
            pEMI->ulBootBlockSize / 1024UL, pEMI->uBootBlockCountLow, pEMI->uBootBlockCountHigh));
    }

    return TRUE;
}


/*-------------------------------------------------------------------
    Unmount()

    Description
        This function dismounts the FIM and releases any allocated
        resources.

    Parameters
        pEMI - A pointer to the ExtndMediaInfo structure to use.

    Return Value
        None
-------------------------------------------------------------------*/
static void Unmount(
    PEXTMEDIAINFO pEMI)
{
    DclAssert(pEMI);
    DclAssert(pEMI->pFimExtra);

    DclMemFree(pEMI->pFimExtra);
    pEMI->pFimExtra = NULL;
}


/*-------------------------------------------------------------------
    Read()

    Description
        Read a given number of bytes of data from the media.

    Parameters
        pEMI    - A pointer to the ExtndMediaInfo structure to use
        ulStart - Starting offset in bytes to begin the access
        uLength - Number of bytes to transfer
        pBuffer - Pointer to client supplied transfer area

    Return Value
        Returns TRUE if successful, else FALSE.
-------------------------------------------------------------------*/
static D_BOOL Read(
    PEXTMEDIAINFO   pEMI,
    D_UINT32        ulStart,
    D_UINT16        uLength,
    void           *pBuffer)
{
    DclAssert(pEMI);

    return FfxFimNorRead(pEMI, ulStart, uLength, pBuffer);
}


/*-------------------------------------------------------------------
    Write()

    Description
        Writes a given number of bytes of data out to the media.
        It does not return until the data is programmed.

    Parameters
        pEMI    - A pointer to the ExtndMediaInfo structure to use.
        ulStart - Starting offset in bytes to begin the access
        uLength - Number of bytes to transfer
        pBuffer - Pointer to client supplied transfer area

    Return Value
        Returns TRUE if successful, else FALSE.
-------------------------------------------------------------------*/
static D_BOOL Write(
    PEXTMEDIAINFO   pEMI,
    D_UINT32        ulStart,
    D_UINT16        uLength,
    void           *pBuffer)
{
    PFLASHDATA      pMedia;
    D_UINT16       *puDataPtr = (D_UINT16 *)pBuffer;
    DCLTIMER        timer;

    DclAssert(pEMI);
    DclAssert(ulStart % sizeof(D_UINT32) == 0L);
    DclAssert(uLength);
    DclAssert(pBuffer);

    /*  Verify user address and length parameters within the media
        boundaries.
    */
    DclAssert(ulStart < pEMI->ulTotalSize);
    DclAssert(pEMI->ulTotalSize - ulStart >= uLength);

    while(uLength)
    {
        D_UINT16    u;
        D_UINT32    ulWindowSize;

        /*  Get the media pointer and the max size we can access with it
        */
        ulWindowSize = FfxFimNorWindowMap(pEMI->hDev, ulStart, (volatile void **)&pMedia);
        if(!ulWindowSize)
        {
            return FALSE;
        }

        /*  Start from a known state
        */
        ResetFlash(pMedia);

        /*  Move each window worth of data into the flash memory.
        */
        while(ulWindowSize && uLength)
        {
            D_UINT32    ulThisLength = DCLMIN(uLength, ulWindowSize);

            /*  Program ulThisLength bytes into flash
            */
            for(u = 0; u < ulThisLength / 2; ++u)
            {
                /*  Don't waste time programming all 1's
                */
                if(puDataPtr[u] != (D_UINT16) 0xFFFF)
                {
                    pMedia[u] = INTLCMD_PROGRAM;
                    pMedia[u] = puDataPtr[u];
                    DclTimerSet(&timer, WRITE_TIMEOUT);

                    /*  Wait till the byte is done programming
                    */
                    while(!(pMedia[u] & INTLSTAT_DONE))
                    {
                        if(DclTimerExpired(&timer))
                        {
                            /*  one final check to make sure read write didn't
                                just complete
                            */
                            if(!(pMedia[u] & INTLSTAT_DONE))
                            {
                                /*  Clear the error status, reset to read mode,
                                    and return
                                */
                                ResetFlash(pMedia);
                                return FALSE;
                            }
                        }
                    }

                    /*  Check for error
                    */
                    if(pMedia[u] & INTLSTAT_WRITE_FAIL)
                    {
                        /*  Clear the error status, reset to read mode and return
                        */
                        ResetFlash(pMedia);
                        return FALSE;
                    }

                }
            }

            /*  If we have written everything, get outta here.
            */
            uLength -= (D_UINT16)ulThisLength;
            if(uLength == 0)
                break;

            /*  Go to the next offset
            */
            ulWindowSize    -= ulThisLength;
            ulStart         += ulThisLength;
            puDataPtr       += ulThisLength / 2;

            DclAssert(ulStart);
            DclAssert(puDataPtr);
        }
    }

    /*  Be sure we leave the flash in the read mode
    */
    ResetFlash(pMedia);

    /*  Return success if all bytes were written correctly
    */
    return TRUE;
}


/*-------------------------------------------------------------------
    EraseStart()

    Description
        Initiate an erase operation.  If successful, the only FIM
        functions that can then be called are EraseSuspend() and
        ErasePoll().  The operation must subsequently be monitored
        by calls to ErasePoll().

        If it is not started successfully, those functions may not
        be called.  The flash is restored to a readable state if
        possible, but this cannot always be guaranteed.

    Parameters
        pEMI    - A pointer to the ExtndMediaInfo structure to use.
        ulStart - Starting offset in bytes to begin the erase.  This
                  must be on a physical erase zone boundary.
        uLength - Number of bytes to erase.  This must be the exact
                  total length of one or more physical erase zones
                  starting at ulStart.

    Return Value
        Returns TRUE if successful, else FALSE.
-------------------------------------------------------------------*/
static D_BOOL EraseStart(
    PEXTMEDIAINFO   pEMI,
    D_UINT32        ulStart,
    D_UINT32        ulLength)
{
    PFLASHDATA      pMedia;
    D_UINT32        ulChipBB;   /* boot block # within the chip */

    DclAssert(pEMI);
    DclAssert(pEMI->pFimExtra);
    DclAssert(ulStart < pEMI->ulTotalSize);
    DclAssert(pEMI->ulTotalSize - ulStart >= ulLength);

    if(pEMI->ulBootBlockSize)
        ulChipBB = (ulStart % pEMI->ulDeviceSize) / pEMI->ulBootBlockSize;
    else
        ulChipBB = 0;

    /*  See if the start address falls within the range for the low
        or high boot blocks.
    */
    if((ulChipBB < pEMI->uBootBlockCountLow) ||
       (pEMI->uBootBlockCountHigh &&
        (ulChipBB >= pEMI->pFimExtra->uHighBootBlockStart)))
    {
        DclAssert(ulStart % pEMI->ulBootBlockSize == 0);
        DclAssert(ulLength % pEMI->ulBootBlockSize == 0);
        DclAssert(ulLength >= pEMI->ulBootBlockSize);

        pEMI->pFimExtra->fInBootBlocks = TRUE;
    }
    else
    {
        DclAssert(ulStart % pEMI->ulEraseZoneSize == 0);
        DclAssert(ulLength % pEMI->ulEraseZoneSize == 0);
        DclAssert(ulLength >= pEMI->ulEraseZoneSize);

        pEMI->pFimExtra->fInBootBlocks = FALSE;
    }

    if(!FfxFimNorWindowMap(pEMI->hDev, ulStart, (volatile void **)&pMedia))
        return FALSE;

    /*  Clear any status from previous operations, then check the status.
    */
    *pMedia = INTLCMD_CLEAR_STATUS;
    *pMedia = INTLCMD_READ_STATUS;

    if((*pMedia & INTLSTAT_STATUS_MASK) == INTLSTAT_DONE)
    {
        /*  The flash appears to be ready, so start the erase.
        */
        *pMedia = INTLCMD_ERASE_START;
        *pMedia = INTLCMD_ERASE_RESUME;

        /*  Set the timeout for the operation now that it's started.
        */
        DclTimerSet(&pEMI->pFimExtra->tErase, ERASE_TIMEOUT);

        /*  Record the erase address for ErasePoll(), EraseSuspend, and
            EraseResume() to use.
        */
        pEMI->pFimExtra->ulEraseStart = ulStart;

        /*  Clear the erase result to signify erase in progress.
        */
        pEMI->pFimExtra->ulEraseResult = ERASE_IN_PROGRESS;

        /*  Remember the media address, save repeated calls to
            FfxHookWindowMap() from ErasePoll().
        */
        pEMI->pFimExtra->pMedia = pMedia;

        return TRUE;
    }
    else
    {
        /*  There's probably something horrid going on like an erase that
            timed out and got suspended.  Try to return the flash to Read
            Array mode and return a failure indication.
        */
        *pMedia = INTLCMD_READ_MODE;
        pEMI->pFimExtra->ulEraseResult = FIMMT_ERASE_FAILED;
        return FALSE;
    }
}


/*-------------------------------------------------------------------
    EraseSuspend()

    Description
        Suspend an erase operation currently in progress, and return
        the flash to normal read mode.  When this function returns,
        the flash may be read.

        If the flash does not support suspending erases, this
        function is not implemented, and the EraseSuspend entry in
        the FIMDEVICE structure must be NULL.

    Parameters
        pEMI     - A pointer to the ExtndMediaInfo structure to use

    Return Value
        Returns TRUE if successful, else FALSE.
-------------------------------------------------------------------*/
static D_BOOL EraseSuspend(
    PEXTMEDIAINFO   pEMI)
{
    D_BOOL          fResult = TRUE;
    PFIMEXTRA       pFimExtra = pEMI->pFimExtra;
    PFLASHDATA      pMedia;

    DclAssert(pFimExtra);
    pMedia = pFimExtra->pMedia;

    /*  Save the remaining timeout period.
    */
    pFimExtra->ulTimeoutRemaining = DclTimerRemaining(&pFimExtra->tErase);

    /*  The flash is expected to be in Read Status mode.
    */
    *pMedia = INTLCMD_ERASE_SUSPEND;

    /*  Wait a while for the flash to go into erase suspend.
    */
    DclTimerSet(&pFimExtra->tErase, ERASE_SUSPEND_TIMEOUT);
    while(!DclTimerExpired(&pFimExtra->tErase))
    {
        if((*pMedia & INTLSTAT_DONE) == INTLSTAT_DONE)
            break;
    }

    /*  Check the status after a possible timeout.  A higher priority
        thread could have preempted between setting the timer or
        checking the status in the loop and checking for expiration.
    */
    if((*pMedia & INTLSTAT_DONE) != INTLSTAT_DONE)
    {
        /*  It really timed out.  This is a Bad Thing.  Record the failure.
        */
        pFimExtra->ulEraseResult = FIMMT_ERASE_FAILED;
        fResult = FALSE;
    }

    /*  Return the flash to Read Array mode whether or not the suspend
        command appeared to have worked (it can't hurt).
    */
    *pMedia = INTLCMD_READ_MODE;

    return fResult;
}


/*-------------------------------------------------------------------
    EraseResume()

    Description
        Resumes an erase that was successfully suspended by
        EraseSuspend().  Once it is resumed, the only FIM functions
        that can be called are EraseSuspend() and ErasePoll().

        If the flash does not support suspending erases, this
        function is not implemented, and the EraseSuspend entry
        in the FIMDEVICE structure must be NULL.

    Parameters
        pEMI     - A pointer to the ExtndMediaInfo structure to use

    Return Value
        None
-------------------------------------------------------------------*/
static void EraseResume(
    PEXTMEDIAINFO   pEMI)
{
    PFIMEXTRA       pFimExtra = pEMI->pFimExtra;
    PFLASHDATA      pMedia;

    DclAssert(pFimExtra);

    /*  If an error occurred in EraseSuspend() the final result of the
        erase was already recorded.  Only operate on the flash if this
        hasn't happened yet.
    */
    if(pFimExtra->ulEraseResult == ERASE_IN_PROGRESS)
    {
        /*  Erases are suspended to perform other operations, so it's
            necessary to remap the window now.
        */
        if(!FfxFimNorWindowMap(pEMI->hDev, pFimExtra->ulEraseStart, (volatile void **)&pMedia))
            return;

        pFimExtra->pMedia = pMedia;

        /*  Clear status from another operation, and put the flash in Read
            Status mode.
        */
        *pMedia = INTLCMD_CLEAR_STATUS;
        *pMedia = INTLCMD_READ_STATUS;

        /*  It's possible that the chip finished its erase before
            EraseSuspend was called.  Don't try to resume a chip
            that is not suspended: experiment shows that it will
            (sometimes?) return to Read Array mode.

            If one of the chips is showing error status, there's
            no point in trying to resume.
        */
        switch (*pMedia & INTLSTAT_STATUS_MASK)
        {
            case INTLSTAT_ERASE_SUSPENDED:
                *pMedia = INTLCMD_ERASE_RESUME;
                break;

            case INTLSTAT_DONE:
                /*  ErasePoll() will report that the erase is done.
                */
                break;

            default:
                /*  Presumably errored out in some fashion.  ErasePoll() will
                    report that the erase failed.
                */
                DclError();
                break;
        }

        /*  Guarantee a minimum erase increment.
        */
        _sysdelay(MINIMUM_ERASE_INCREMENT);

        /*  Restart the timer.  Note that this will be done in the (unlikely)
            case that both chips had already finished when they were suspended.
            This is harmless, as ErasePoll() checks their status before checking
            for timeout.
        */
        DclTimerSet(&pFimExtra->tErase, pFimExtra->ulTimeoutRemaining);
    }
}


/*-------------------------------------------------------------------
    ErasePoll()

    Description
        Monitor the status of an erase begun with EraseStart().

        If the erase fails, attempts to return the flash to its
        normal read mode.  Depending on the type of flash, this
        may or may not be possible.  If it is possible, it may be
        achieved by suspending the erase operation rather than by
        terminating it.  In this case, it may be possible to read
        the flash, but not to erase it further.

        This function may be called with the flash either in read
        array mode or in read status mode.

    Parameters
        pEMI     - A pointer to the ExtndMediaInfo structure to use

    Return Value
        If the erase is still in progress, returns 0.  The only FIM
        functions that can then be called are EraseSuspend() and
        ErasePoll().

        If the erase completed successfully, returns the length of
        the erase zone actually erased.  This may be less than the
        ulLength value supplied to EraseStart().  The flash is in
        normal read mode.

        If the erase failed, returns FIMMT_ERASE_FAILED, which is a
        value that could never be a valid erase length.  The flash
        is returned to normal read mode if possible, but this may not
        be possible in all cases (for example, if the flash does not
        support suspending an erase, and the operation times out).
-------------------------------------------------------------------*/
static D_UINT32 ErasePoll(
    PEXTMEDIAINFO   pEMI)
{
    PFIMEXTRA       pFimExtra = pEMI->pFimExtra;
    PFLASHDATA      pMedia;

    DclAssert(pFimExtra);

    /*  ErasePoll() may be called multiple times even after the
        operation has completed.  Only check the flash if it
        has not already been seen to have finished its operation.
    */
    if(pFimExtra->ulEraseResult == ERASE_IN_PROGRESS)
    {
        /*  The erase was still in progress the last time it was checked.
            It is expected to have been left in Read Status mode by the
            last call to ErasePoll() or EraseResume().  Don't issue a
            Read Status command here (think about what happens if the
            flash was unexpectedly reset).

            The erase is not done until both chips' status registers have
            the DONE bit set.
        */
        pMedia = pFimExtra->pMedia;
        if((*pMedia & INTLSTAT_DONE) == INTLSTAT_DONE)
        {
            /*  On normal completion, the status register has the DONE
                bit set, and all other meaningful bits clear.
            */
            if((*pMedia & INTLSTAT_STATUS_MASK) == INTLSTAT_DONE)
            {
                /*  The erase has completed successfully.  One erase zone
                    has been erased.
                */
                if(pFimExtra->fInBootBlocks)
                    pFimExtra->ulEraseResult = pEMI->ulBootBlockSize;
                else
                    pFimExtra->ulEraseResult = pEMI->ulEraseZoneSize;
            }
            else
            {
                /*  The status register indicates something other than
                    normal completion.
                */
                pFimExtra->ulEraseResult = FIMMT_ERASE_FAILED;
            }

            /*  Whether or not there was an error, return the flash to
                Read Array mode.
            */
            *pMedia = INTLCMD_READ_MODE;
        }
        else if(DclTimerExpired(&pFimExtra->tErase) &&
                (*pMedia & INTLSTAT_DONE) != INTLSTAT_DONE)
        {
            /*  The erase hasn't finished, and the timeout has elapsed.
                Try to return the flash to Read Array mode by suspending
                the erase, and return a failure indication.

                The extra check of status after the timeout check may
                look a little odd -- wasn't it just checked above?  This
                is to handle perverse platforms on which power management
                can suspend the CPU any old time, but the flash keeps
                erasing.  Yes, this really happens.
            */
            EraseSuspend(pEMI);
            pFimExtra->ulEraseResult = FIMMT_ERASE_FAILED;
        }
    }
    return pFimExtra->ulEraseResult;
}


/*-------------------------------------------------------------------
    ResetFlash()

    Description
        Resets the flash memory by clearing the error status and
        returning to the read mode.

    Parameters
        pMediaPtr - pointer to flash media

    Return Value
        None
-------------------------------------------------------------------*/
static void ResetFlash(
    PFLASHDATA      pMedia)
{
    /*  Initialize flash memory for byte x8 mode
    */
    *pMedia = INTLCMD_READ_MODE;
    *pMedia = INTLCMD_CLEAR_STATUS;
    *pMedia = INTLCMD_READ_MODE;
}


/*-------------------------------------------------------------------
    FIMDEVICE Declaration

    This structure declaration is used to define the entry points
    into the FIM.  This is declared at the end of the module to
    eliminate the need for what would be duplicated function
    prototypes in all the FIMs.
-------------------------------------------------------------------*/
FIMDEVICE FFXFIM_iffx16 =
{
    Mount,
    Unmount,
    Read,
    Write,
    EraseStart,
    ErasePoll,
    EraseSuspend,
    EraseResume
};

